<%= form_with(model: listing, local: true, multipart: true) do |form| %>
  <% if listing.errors.any? %>
    <div class="form-errors">
      <h2><%= pluralize(listing.errors.count, "error") %> prohibited this listing from being saved:</h2>
      <ul>
        <% listing.errors.each do |error| %>
          <li><%= error.full_message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <div class="form-container">
    <div class="form-section">
      <h2>Basic Information</h2>
      
      <div class="form-field">
        <%= form.label :title, "Title *" %>
        <%= form.text_field :title, placeholder: "e.g., iPhone 13 Pro Max 256GB" %>
      </div>

      <div class="form-field">
        <%= form.label :category_id, "Category *" %>
        <%= form.collection_select :category_id, Category.visible.order(:name), :id, :name, 
            { prompt: "Select a category", selected: listing.category_id }, 
            { class: "form-select", required: true, id: "listing_category_id", onchange: "showCategoryFields()" } %>
      </div>

      <!-- Subcategory for all categories (options populated by JS from category_subcategories) -->
      <% is_motors_category = listing.category&.name&.downcase&.include?('motor') || listing.category&.name&.downcase&.include?('car') || (listing.persisted? && listing.category_id && Category.find_by(id: listing.category_id)&.name&.downcase&.include?('motor')) %>
      <% any_category_selected = listing.category_id.present? || is_motors_category %>
      <div class="form-field" id="subcategory-field" style="<%= any_category_selected ? 'display: block;' : 'display: none;' %>">
        <label for="listing_subcategory">Subcategory *</label>
        <select name="listing[subcategory]" id="listing_subcategory" class="form-select" data-current-subcategory="<%= listing.extra_fields&.dig('subcategory') %>">
          <option value="">Select subcategory</option>
          <%# Options are populated by showCategoryFields() from window.categorySubcategories %>
        </select>
      </div>
      <script>
        window.categorySubcategories = <%= raw category_subcategories_json %>;
      </script>

      <div class="form-field">
        <%= form.label :description, "Description *" %>
        <%= form.text_area :description, rows: 6, placeholder: "Describe your item in detail..." %>
      </div>
    </div>

    <!-- Category-Specific Fields (Motors/Cars) -->
    <div class="form-section" id="motors-fields" style="<%= is_motors_category ? 'display: block;' : 'display: none;' %>">
      <h2>Vehicle Details</h2>
      
      <div class="form-field">
        <label for="vehicle_registration_lookup">Vehicle Registration (Auto-fill details)</label>
        <div style="display: flex; gap: 0.5rem; align-items: flex-end;">
          <input type="text" id="vehicle_registration_lookup" placeholder="e.g., 181-D-12345" style="text-transform: uppercase; flex: 1;" class="form-input">
          <button type="button" id="lookup_registration_btn" class="btn-lookup" style="padding: 0.75rem 1.5rem; background: #4FD1A5; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Lookup</button>
        </div>
        <p class="form-help" style="margin-top: 0.5rem; font-size: 0.7rem; color: #9CA3AF; line-height: 1.4;">
          Enter your vehicle registration to auto-fill details. 
          <span style="font-weight: 500; color: #6B7280;">Your registration number will not be displayed publicly.</span>
        </p>
        <div id="lookup_status" style="margin-top: 0.5rem; display: none;"></div>
      </div>
      
      <!-- Hidden fields for vehicle data from registration lookup -->
      <input type="hidden" name="listing[vehicle_registration]" id="listing_vehicle_registration" value="<%= listing.extra_fields&.dig('vehicle_registration') %>">
      <input type="hidden" name="listing[performance]" id="listing_performance" value="<%= listing.extra_fields&.dig('performance')&.to_json if listing.extra_fields&.dig('performance') %>">
      <input type="hidden" name="listing[dimensions]" id="listing_dimensions" value="<%= listing.extra_fields&.dig('dimensions')&.to_json if listing.extra_fields&.dig('dimensions') %>">
      <input type="hidden" name="listing[features]" id="listing_features" value="<%= listing.extra_fields&.dig('features')&.to_json if listing.extra_fields&.dig('features') %>">
      <input type="hidden" name="listing[running_costs]" id="listing_running_costs" value="<%= listing.extra_fields&.dig('running_costs')&.to_json if listing.extra_fields&.dig('running_costs') %>">
      
      <div class="form-row">
        <div class="form-field">
          <label for="listing_make">Make</label>
          <select name="listing[make]" id="listing_make" class="form-select" onchange="if(window.updateListingModels) { console.log('Make changed via onchange, calling updateListingModels'); window.updateListingModels(); } else { console.error('updateListingModels not available on change'); }">
            <option value="">All Makes</option>
            <option value="Alfa Romeo" <%= 'selected' if listing.extra_fields&.dig('make') == 'Alfa Romeo' %>>Alfa Romeo</option>
            <option value="Aston Martin" <%= 'selected' if listing.extra_fields&.dig('make') == 'Aston Martin' %>>Aston Martin</option>
            <option value="Audi" <%= 'selected' if listing.extra_fields&.dig('make') == 'Audi' %>>Audi</option>
            <option value="Bentley" <%= 'selected' if listing.extra_fields&.dig('make') == 'Bentley' %>>Bentley</option>
            <option value="BMW" <%= 'selected' if listing.extra_fields&.dig('make') == 'BMW' %>>BMW</option>
            <option value="Chevrolet" <%= 'selected' if listing.extra_fields&.dig('make') == 'Chevrolet' %>>Chevrolet</option>
            <option value="Chrysler" <%= 'selected' if listing.extra_fields&.dig('make') == 'Chrysler' %>>Chrysler</option>
            <option value="Citroen" <%= 'selected' if listing.extra_fields&.dig('make') == 'Citroen' %>>Citroen</option>
            <option value="Dacia" <%= 'selected' if listing.extra_fields&.dig('make') == 'Dacia' %>>Dacia</option>
            <option value="Dodge" <%= 'selected' if listing.extra_fields&.dig('make') == 'Dodge' %>>Dodge</option>
            <option value="Ferrari" <%= 'selected' if listing.extra_fields&.dig('make') == 'Ferrari' %>>Ferrari</option>
            <option value="Fiat" <%= 'selected' if listing.extra_fields&.dig('make') == 'Fiat' %>>Fiat</option>
            <option value="Ford" <%= 'selected' if listing.extra_fields&.dig('make') == 'Ford' %>>Ford</option>
            <option value="Honda" <%= 'selected' if listing.extra_fields&.dig('make') == 'Honda' %>>Honda</option>
            <option value="Hyundai" <%= 'selected' if listing.extra_fields&.dig('make') == 'Hyundai' %>>Hyundai</option>
            <option value="Infiniti" <%= 'selected' if listing.extra_fields&.dig('make') == 'Infiniti' %>>Infiniti</option>
            <option value="Jaguar" <%= 'selected' if listing.extra_fields&.dig('make') == 'Jaguar' %>>Jaguar</option>
            <option value="Jeep" <%= 'selected' if listing.extra_fields&.dig('make') == 'Jeep' %>>Jeep</option>
            <option value="Kia" <%= 'selected' if listing.extra_fields&.dig('make') == 'Kia' %>>Kia</option>
            <option value="Lamborghini" <%= 'selected' if listing.extra_fields&.dig('make') == 'Lamborghini' %>>Lamborghini</option>
            <option value="Land Rover" <%= 'selected' if listing.extra_fields&.dig('make') == 'Land Rover' %>>Land Rover</option>
            <option value="Lexus" <%= 'selected' if listing.extra_fields&.dig('make') == 'Lexus' %>>Lexus</option>
            <option value="Maserati" <%= 'selected' if listing.extra_fields&.dig('make') == 'Maserati' %>>Maserati</option>
            <option value="Mazda" <%= 'selected' if listing.extra_fields&.dig('make') == 'Mazda' %>>Mazda</option>
            <option value="McLaren" <%= 'selected' if listing.extra_fields&.dig('make') == 'McLaren' %>>McLaren</option>
            <option value="Mercedes-Benz" <%= 'selected' if listing.extra_fields&.dig('make') == 'Mercedes-Benz' %>>Mercedes-Benz</option>
            <option value="Mini" <%= 'selected' if listing.extra_fields&.dig('make') == 'Mini' %>>Mini</option>
            <option value="Mitsubishi" <%= 'selected' if listing.extra_fields&.dig('make') == 'Mitsubishi' %>>Mitsubishi</option>
            <option value="Nissan" <%= 'selected' if listing.extra_fields&.dig('make') == 'Nissan' %>>Nissan</option>
            <option value="Opel" <%= 'selected' if listing.extra_fields&.dig('make') == 'Opel' %>>Opel</option>
            <option value="Peugeot" <%= 'selected' if listing.extra_fields&.dig('make') == 'Peugeot' %>>Peugeot</option>
            <option value="Porsche" <%= 'selected' if listing.extra_fields&.dig('make') == 'Porsche' %>>Porsche</option>
            <option value="Renault" <%= 'selected' if listing.extra_fields&.dig('make') == 'Renault' %>>Renault</option>
            <option value="Rolls-Royce" <%= 'selected' if listing.extra_fields&.dig('make') == 'Rolls-Royce' %>>Rolls-Royce</option>
            <option value="Seat" <%= 'selected' if listing.extra_fields&.dig('make') == 'Seat' %>>Seat</option>
            <option value="Skoda" <%= 'selected' if listing.extra_fields&.dig('make') == 'Skoda' %>>Skoda</option>
            <option value="Smart" <%= 'selected' if listing.extra_fields&.dig('make') == 'Smart' %>>Smart</option>
            <option value="Subaru" <%= 'selected' if listing.extra_fields&.dig('make') == 'Subaru' %>>Subaru</option>
            <option value="Suzuki" <%= 'selected' if listing.extra_fields&.dig('make') == 'Suzuki' %>>Suzuki</option>
            <option value="Tesla" <%= 'selected' if listing.extra_fields&.dig('make') == 'Tesla' %>>Tesla</option>
            <option value="Toyota" <%= 'selected' if listing.extra_fields&.dig('make') == 'Toyota' %>>Toyota</option>
            <option value="Vauxhall" <%= 'selected' if listing.extra_fields&.dig('make') == 'Vauxhall' %>>Vauxhall</option>
            <option value="Volkswagen" <%= 'selected' if listing.extra_fields&.dig('make') == 'Volkswagen' %>>Volkswagen</option>
            <option value="Volvo" <%= 'selected' if listing.extra_fields&.dig('make') == 'Volvo' %>>Volvo</option>
          </select>
        </div>
        
        <div class="form-field">
          <label for="listing_model">Model</label>
          <select name="listing[model]" id="listing_model" class="form-select">
            <option value="">Select Model</option>
          </select>
        </div>
      </div>

      <div class="form-row">
        <div class="form-field">
          <label for="listing_year">Year</label>
          <select name="listing[year]" id="listing_year" class="form-select">
            <option value="">Select Year</option>
            <% (1990..Date.current.year + 1).to_a.reverse.each do |year| %>
              <option value="<%= year %>" <%= 'selected' if listing.extra_fields&.dig('year') == year.to_s %>><%= year %></option>
            <% end %>
          </select>
        </div>
        
        <div class="form-field">
          <label for="listing_mileage">Mileage (km)</label>
          <input type="number" name="listing[mileage]" id="listing_mileage" value="<%= listing.extra_fields&.dig('mileage') %>" placeholder="e.g., 50000" min="0" class="form-input">
        </div>
      </div>

      <div class="form-row">
        <div class="form-field">
          <label for="listing_engine_size">Engine Size</label>
          <input type="text" name="listing[engine_size]" id="listing_engine_size" value="<%= listing.extra_fields&.dig('engine_size') %>" placeholder="e.g., 1.6L, 2.0L" class="form-input">
        </div>
        
        <div class="form-field">
          <label for="listing_fuel_type">Fuel Type</label>
          <select name="listing[fuel_type]" id="listing_fuel_type" class="form-select">
            <option value="">Select fuel type</option>
            <option value="Petrol" <%= 'selected' if listing.extra_fields&.dig('fuel_type') == 'Petrol' %>>Petrol</option>
            <option value="Diesel" <%= 'selected' if listing.extra_fields&.dig('fuel_type') == 'Diesel' %>>Diesel</option>
            <option value="Electric" <%= 'selected' if listing.extra_fields&.dig('fuel_type') == 'Electric' %>>Electric</option>
            <option value="Hybrid" <%= 'selected' if listing.extra_fields&.dig('fuel_type') == 'Hybrid' %>>Hybrid</option>
            <option value="Other" <%= 'selected' if listing.extra_fields&.dig('fuel_type') == 'Other' %>>Other</option>
          </select>
        </div>
      </div>

      <div class="form-row">
        <div class="form-field">
          <label for="listing_transmission">Transmission</label>
          <select name="listing[transmission]" id="listing_transmission" class="form-select">
            <option value="">Select transmission</option>
            <option value="Manual" <%= 'selected' if listing.extra_fields&.dig('transmission') == 'Manual' %>>Manual</option>
            <option value="Automatic" <%= 'selected' if listing.extra_fields&.dig('transmission') == 'Automatic' %>>Automatic</option>
          </select>
        </div>
        
        <div class="form-field">
          <label for="listing_previous_owners">Total Owners</label>
          <input type="number" name="listing[previous_owners]" id="listing_previous_owners" value="<%= listing.extra_fields&.dig('previous_owners') %>" placeholder="e.g., 2" min="0" class="form-input">
        </div>
      </div>

      <!-- Hidden fields for vehicle data from registration lookup -->
      <input type="hidden" name="listing[vehicle_registration]" id="listing_vehicle_registration" value="<%= listing.extra_fields&.dig('vehicle_registration') %>">
      <input type="hidden" name="listing[performance]" id="listing_performance" value="<%= listing.extra_fields&.dig('performance')&.to_json %>">
      <input type="hidden" name="listing[dimensions]" id="listing_dimensions" value="<%= listing.extra_fields&.dig('dimensions')&.to_json %>">
      <input type="hidden" name="listing[features]" id="listing_features" value="<%= listing.extra_fields&.dig('features')&.to_json %>">
      <input type="hidden" name="listing[running_costs]" id="listing_running_costs" value="<%= listing.extra_fields&.dig('running_costs')&.to_json %>">
    </div>

    <div class="form-section">
      <h2>Pricing & Location</h2>
      
      <div class="form-field">
        <%= form.label :price, "Price (€) *" %>
        <%= form.number_field :price, step: 0.01, min: 0, placeholder: "0.00" %>
      </div>

      <div class="form-field">
        <%= form.label :city, "County *" %>
        <%= form.select :city, options_for_select(irish_counties.map { |county| [county, county] }, listing.city), 
            { prompt: "Select a county" }, { class: "form-select", required: true } %>
      </div>
    </div>

    <div class="form-section">
      <h2>Photos and Video</h2>
      <p class="form-help" style="margin-bottom: 1.5rem; color: #6b7280;">Up to 10 photos</p>
      
      <!-- Drag and Drop Upload Zone -->
      <div class="image-upload-zone" id="image-upload-zone">
        <%= form.file_field :images, multiple: true, accept: "image/jpeg,image/png,image/gif,image/jpg,image/webp", class: "image-upload-input-hidden", id: "image-upload-input" %>
        <div class="upload-zone-content">
          <div class="upload-icon">
            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M7 18C4.23858 18 2 15.7614 2 13C2 10.2386 4.23858 8 7 8C7.34147 8 7.67314 8.03428 7.99143 8.09796C8.68723 5.76256 10.7206 4 13 4C16.3137 4 19 6.68629 19 10C20.1046 10 21 10.8954 21 12C21 13.1046 20.1046 14 19 14H7Z" stroke="#60A5FA" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M12 8V16M8 12L12 8L16 12" stroke="#60A5FA" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <p class="upload-primary-text">Add Photos</p>
          <p class="upload-secondary-text">or drag and drop</p>
          <p class="upload-info-text">Up to 10 images</p>
          <p class="upload-format-text">.jpg, .png, .gif and .webp files</p>
        </div>
      </div>

      <!-- Hidden input to store image order -->
      <input type="hidden" id="image-order" name="image_order" value="">
      <!-- Hidden input to store combined order (new + existing) -->
      <input type="hidden" id="combined-image-order" name="combined_image_order" value="">

      <%# Always render the thumbnails grid so selected photos can preview reliably on mobile/desktop %>
      <div class="existing-images" style="margin-top: 1.5rem; display: block;">
        <% if listing.persisted? && listing.images.attached? %>
          <p class="form-help">Current images (drag to reorder, click × to remove):</p>
        <% else %>
          <p class="form-help">Selected images (drag to reorder, click × to remove):</p>
        <% end %>

        <% if listing.persisted? %>
          <% ordered_existing_images = listing.ordered_images.to_a %>
          <%# Get current order for hidden input (existing attachments) %>
          <% current_order_ids = ordered_existing_images.map { |img|
               attachment = listing.images_attachments.find { |a| a.blob_id == img.id }
               attachment&.id
             }.compact.reject(&:nil?) %>
          <% order_value = current_order_ids.any? ? current_order_ids.join(',') : '' %>
          <input type="hidden" id="existing-image-order-container" name="existing_image_order" value="<%= order_value %>">
        <% end %>
        
        <!-- Compact thumbnail grid - draggable, always visible -->
        <div class="image-thumbnails-grid" id="image-thumbnails-grid" data-draggable-container="true" data-accepts-new-images="true" style="display: grid !important; visibility: visible !important;">
          <% if listing.persisted? && listing.images.attached? %>
            <% ordered_existing_images.each_with_index do |img, index| %>
              <% attachment = listing.images_attachments.find { |a| a.blob_id == img.id } %>
              <% image_id = attachment&.id || img.id %>
              <div class="image-thumbnail-item existing-image-item image-item" 
                   data-image-id="<%= image_id %>" 
                   data-image-index="<%= index %>"
                   data-is-existing="true"
                   draggable="true"
                   style="display: block !important; visibility: visible !important;">
                <%= image_tag url_for(img), class: "thumbnail-image", draggable: "false", style: "display: block !important;" %>
                <button type="button" class="remove-thumbnail-image" data-image-id="<%= image_id %>" title="Remove image">×</button>
                <% if index == 0 %>
                  <span class="main-badge-existing">COVER</span>
                <% end %>
              </div>
            <% end %>
          <% end %>
        </div>
        
        <p class="form-help" style="margin-top: 0.75rem; color: #6b7280; font-size: 0.875rem;">
          You can add more images using the upload zone above.
        </p>
      </div>
    </div>

    <% unless listing.persisted? %>
      <div class="form-field boost-ad-option">
        <label class="boost-ad-option-label">
          <%= check_box_tag "boost_listing", "1", false, class: "boost-ad-checkbox" %>
          <span>Boost ad for 7 days for €0.99</span>
        </label>
        <p class="form-help">Your listing will get more visibility for 7 days. Verified Sellers get 3 free boosts every month — <%= link_to "upgrade here", verified_seller_path, data: { turbo: "false" }, class: "form-help-link" %>.</p>
      </div>
    <% end %>

    <div class="form-actions">
      <%= form.submit listing.persisted? ? "Update Listing" : "Create Listing", class: "btn-submit", id: "listing-submit-btn" %>
      <%= link_to "Cancel", listing.persisted? ? listing_path(listing) : listings_path, class: "btn-cancel" %>
    </div>
  </div>
<% end %>

<script>
  // Make sure carModels and updateListingModels are available globally
  // Initialize as null first, will be set below
  window.carModels = null;
  window.updateListingModels = null;
  
  function showCategoryFields() {
    const categorySelect = document.getElementById('listing_category_id');
    const motorsFields = document.getElementById('motors-fields');
    const subcategoryField = document.getElementById('subcategory-field');
    const subcategorySelect = document.getElementById('listing_subcategory');
    
    if (!categorySelect) return;
    
    const selectedCategoryId = categorySelect.value;
    const selectedCategoryText = categorySelect.options[categorySelect.selectedIndex]?.text || '';
    
    // Check if Motors category is selected (by name or by checking if it's a motors category)
    const isMotors = selectedCategoryText.toLowerCase().includes('motor') || 
                     selectedCategoryText.toLowerCase().includes('car') ||
                     (selectedCategoryId && selectedCategoryText === 'Motors');
    
    // Show subcategory for any selected category; populate from window.categorySubcategories
    if (selectedCategoryId && selectedCategoryText && selectedCategoryText !== 'Select a category') {
      if (subcategoryField) subcategoryField.style.display = 'block';
      if (subcategorySelect && window.categorySubcategories) {
        const subs = window.categorySubcategories[selectedCategoryText] || window.categorySubcategories['Motors'] || [];
        const currentVal = subcategorySelect.getAttribute('data-current-subcategory') || subcategorySelect.value;
        subcategorySelect.innerHTML = '<option value="">Select subcategory</option>';
        subs.forEach(function(s) {
          const opt = document.createElement('option');
          opt.value = s;
          opt.textContent = s;
          subcategorySelect.appendChild(opt);
        });
        if (currentVal && subs.indexOf(currentVal) !== -1) subcategorySelect.value = currentVal;
        subcategorySelect.removeAttribute('data-current-subcategory');
      }
    } else {
      if (subcategoryField) subcategoryField.style.display = 'none';
      if (subcategorySelect) subcategorySelect.value = '';
    }
    
    if (isMotors) {
      if (motorsFields) motorsFields.style.display = 'block';
      if (window.updateListingModels) {
        setTimeout(function() { window.updateListingModels(); }, 50);
      }
    } else {
      if (motorsFields) motorsFields.style.display = 'none';
      // Clear vehicle-related fields when switching away from Motors
      const makeSelect = document.getElementById('listing_make');
      const modelSelect = document.getElementById('listing_model');
      const vehicleRegistrationInput = document.getElementById('vehicle_registration_lookup');
      const vehicleRegistrationHidden = document.getElementById('listing_vehicle_registration');
      if (makeSelect) makeSelect.value = '';
      if (modelSelect) {
        modelSelect.innerHTML = '<option value="">Select Model</option>';
        modelSelect.value = '';
      }
      if (vehicleRegistrationInput) vehicleRegistrationInput.value = '';
      if (vehicleRegistrationHidden) vehicleRegistrationHidden.value = '';
      ['listing_performance', 'listing_dimensions', 'listing_features', 'listing_running_costs'].forEach(function(id) {
        const el = document.getElementById(id);
        if (el) el.value = '';
      });
    }
  }
  
  // Comprehensive car make-model relationships
  window.carModels = {
    'Audi': ['A1', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'Q2', 'Q3', 'Q5', 'Q7', 'Q8', 'TT', 'R8', 'e-tron', 'e-tron GT', 'RS3', 'RS4', 'RS5', 'RS6', 'RS7', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8'],
    'BMW': ['1 Series', '2 Series', '3 Series', '4 Series', '5 Series', '6 Series', '7 Series', '8 Series', 'X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'Z4', 'i3', 'i4', 'iX', 'iX3', 'M2', 'M3', 'M4', 'M5', 'M8', 'X3 M', 'X4 M', 'X5 M', 'X6 M'],
    'Mercedes-Benz': ['A-Class', 'B-Class', 'C-Class', 'E-Class', 'S-Class', 'CLA', 'CLS', 'GLA', 'GLB', 'GLC', 'GLE', 'GLS', 'SL', 'AMG GT', 'EQC', 'EQS', 'EQE', 'C63 AMG', 'E63 AMG', 'S63 AMG', 'G63 AMG'],
    'Volkswagen': ['Golf', 'Polo', 'Passat', 'Jetta', 'Tiguan', 'Touareg', 'Arteon', 'T-Cross', 'T-Roc', 'ID.3', 'ID.4', 'ID.5', 'ID.Buzz', 'Beetle', 'Up!', 'Scirocco', 'Sharan', 'Touran', 'Amarok', 'Caddy', 'Fox', 'Lupo', 'Eos', 'CC', 'Phaeton'],
    'Ford': ['Fiesta', 'Focus', 'Mondeo', 'Kuga', 'Edge', 'Explorer', 'Mustang', 'Puma', 'EcoSport', 'Ranger', 'Transit', 'S-Max', 'Galaxy', 'Tourneo', 'Fusion', 'Escape', 'Expedition', 'F-150', 'Ka', 'C-Max', 'Grand C-Max', 'Bronco', 'Maverick', 'Territory', 'Falcon'],
    'Toyota': ['Aygo', 'Yaris', 'Corolla', 'Camry', 'Prius', 'C-HR', 'RAV4', 'Highlander', 'Land Cruiser', 'Hilux', 'Proace', 'Avensis', 'Auris', 'Verso', 'GT86', 'Supra', 'bZ4X', 'Vitz', 'Celica', 'MR2', 'Tundra', 'Sequoia', 'Sienna', 'Tacoma', '4Runner', 'Matrix', 'FJ Cruiser'],
    'Honda': ['Civic', 'Accord', 'CR-V', 'HR-V', 'Pilot', 'Fit', 'Jazz', 'Insight', 'Ridgeline', 'Passport', 'Odyssey', 'e', 'CR-Z', 'NSX', 'City', 'S2000', 'Prelude', 'Element', 'Crosstour'],
    'Hyundai': ['i10', 'i20', 'i30', 'Elantra', 'Sonata', 'Tucson', 'Santa Fe', 'Kona', 'Ioniq', 'Palisade', 'Venue', 'Nexo', 'IONIQ 5', 'IONIQ 6', 'Genesis', 'Veloster', 'Accent', 'Azera', 'Equus', 'Veracruz', 'Tiburon', 'XG', 'Grandeur'],
    'Nissan': ['Micra', 'Sentra', 'Altima', 'Maxima', 'Juke', 'Qashqai', 'X-Trail', 'Pathfinder', 'Armada', 'Leaf', 'Ariya', '370Z', 'GT-R', 'Navara', 'Note', 'Pulsar', 'Almera', 'Primera', '350Z', 'Murano', 'Rogue', 'Frontier', 'Titan', 'Versa', 'Kicks'],
    'Renault': ['Clio', 'Megane', 'Scenic', 'Kadjar', 'Captur', 'Koleos', 'Talisman', 'Zoe', 'Twingo', 'Kangoo', 'Trafic', 'Master', 'Arkana', 'Austral', 'Laguna', 'Fluence', 'Wind', 'Modus', 'Espace', 'Vel Satis'],
    'Peugeot': ['108', '208', '308', '508', '2008', '3008', '5008', 'Partner', 'Expert', 'Boxer', 'Rifter', 'Traveller', 'e-208', 'e-2008', '107', '207', '307', '407', '607', '1007', '4007', 'RCZ'],
    'Citroen': ['C1', 'C3', 'C4', 'C5', 'Berlingo', 'Cactus', 'C4 Picasso', 'Grand C4 Picasso', 'SpaceTourer', 'Jumper', 'e-C4', 'Ami', 'C2', 'C6', 'C8', 'DS3', 'DS4', 'DS5', 'Xantia', 'Xsara', 'C15'],
    'Skoda': ['Fabia', 'Octavia', 'Superb', 'Kodiaq', 'Karoq', 'Kamiq', 'Scala', 'Enyaq', 'Rapid', 'Yeti', 'Citigo'],
    'Seat': ['Ibiza', 'Leon', 'Ateca', 'Tarraco', 'Arona', 'Formentor', 'Alhambra', 'Altea', 'Toledo', 'Cupra Born', 'Cupra Formentor', 'Mii', 'Exeo', 'Cordoba'],
    'Mazda': ['Mazda2', 'Mazda3', 'Mazda6', 'CX-3', 'CX-5', 'CX-9', 'CX-30', 'MX-5', 'MX-30', 'BT-50', 'CX-50', 'CX-60', 'CX-70', 'CX-90', 'RX-7', 'RX-8', 'MPV', 'Tribute'],
    'Kia': ['Picanto', 'Rio', 'Ceed', 'Optima', 'Sportage', 'Sorento', 'Stonic', 'Niro', 'EV6', 'Soul', 'Seltos', 'Telluride', 'Carnival', 'Stinger', 'Ceed SW', 'ProCeed', 'Xceed', 'Mohave', 'Borrego'],
    'Volvo': ['V40', 'V60', 'V90', 'XC40', 'XC60', 'XC90', 'S60', 'S90', 'C30', 'C70', 'XC70', 'EX30', 'EX90', 'S40', 'S80', 'V50', 'V70', 'XC30', '850', '240', '740', '940'],
    'Opel': ['Corsa', 'Astra', 'Insignia', 'Crossland', 'Grandland', 'Mokka', 'Adam', 'Karl', 'Combo', 'Vivaro', 'Movano', 'Corsa-e', 'Mokka-e', 'Vectra', 'Zafira', 'Meriva', 'Tigra', 'Agila', 'Antara', 'Cascada'],
    'Vauxhall': ['Corsa', 'Astra', 'Insignia', 'Crossland', 'Grandland', 'Mokka', 'Adam', 'Karl', 'Combo', 'Vivaro', 'Movano', 'Corsa-e', 'Mokka-e', 'Vectra', 'Zafira', 'Meriva', 'Tigra', 'Agila', 'Antara', 'Cascada'],
    'Fiat': ['500', 'Panda', 'Punto', 'Tipo', '500X', '500L', 'Doblo', 'Qubo', 'Talento', 'Ducato', '500e', 'Bravo', 'Brava', 'Stilo', 'Multipla', 'Ulysse', 'Sedici', 'Linea', 'Grande Punto'],
    'Suzuki': ['Swift', 'Vitara', 'S-Cross', 'Jimny', 'Ignis', 'SX4', 'Baleno', 'Celerio', 'Across', 'Splash', 'Kizashi', 'Grand Vitara', 'XL7', 'Samurai'],
    'Mitsubishi': ['Mirage', 'Lancer', 'Outlander', 'ASX', 'Eclipse Cross', 'Shogun', 'Pajero', 'i-MiEV', 'Colt', 'Galant', 'Eclipse', '3000GT', 'Diamante', 'Montero', 'Space Star'],
    'Subaru': ['Impreza', 'Legacy', 'Outback', 'Forester', 'XV', 'BRZ', 'Ascent', 'WRX', 'Levorg', 'Tribeca', 'Baja', 'SVX', 'Justy', 'B9 Tribeca'],
    'Jaguar': ['XE', 'XF', 'XJ', 'F-Pace', 'E-Pace', 'I-Pace', 'F-Type', 'XK', 'X-Type', 'S-Type', 'XFR', 'XKR', 'XJ220'],
    'Land Rover': ['Discovery', 'Discovery Sport', 'Range Rover', 'Range Rover Sport', 'Range Rover Evoque', 'Defender', 'Range Rover Velar', 'Freelander', 'LR2', 'LR3', 'LR4'],
    'Lexus': ['IS', 'ES', 'GS', 'LS', 'NX', 'RX', 'UX', 'GX', 'LX', 'LC', 'RC', 'CT', 'SC', 'HS', 'LFA'],
    'Porsche': ['911', '718', 'Panamera', 'Macan', 'Cayenne', 'Taycan', 'Boxster', 'Cayman', '924', '928', '944', '968', '959', 'Carrera GT'],
    'Tesla': ['Model 3', 'Model S', 'Model X', 'Model Y', 'Roadster', 'Cybertruck'],
    'Mini': ['Hatch', 'Clubman', 'Countryman', 'Convertible', 'Paceman', 'Coupe', 'Roadster', 'Cooper', 'Cooper S', 'John Cooper Works', 'Electric'],
    'Smart': ['Fortwo', 'Forfour', 'EQ Fortwo', 'EQ Forfour'],
    'Dacia': ['Sandero', 'Duster', 'Logan', 'Lodgy', 'Dokker', 'Spring'],
    'Chevrolet': ['Spark', 'Cruze', 'Malibu', 'Equinox', 'Tahoe', 'Silverado', 'Traverse', 'Blazer', 'Camaro', 'Corvette', 'Bolt', 'Impala', 'Suburban', 'Colorado', 'Aveo', 'Sonic', 'Trax', 'Volt'],
    'Chrysler': ['300', 'Pacifica', 'Voyager', 'Grand Caravan', '200', 'Sebring', 'PT Cruiser', 'Crossfire', 'Aspen', 'Town & Country'],
    'Dodge': ['Charger', 'Challenger', 'Durango', 'Journey', 'Grand Caravan', 'Ram', 'Dart', 'Avenger', 'Caliber', 'Magnum', 'Neon', 'Intrepid', 'Stratus', 'Viper'],
    'Jeep': ['Renegade', 'Compass', 'Cherokee', 'Grand Cherokee', 'Wrangler', 'Gladiator', 'Wagoneer', 'Patriot', 'Liberty', 'Commander'],
    'Alfa Romeo': ['Giulia', 'Stelvio', '4C', 'Giulietta', 'Mito', '159', 'Brera', '147', '156', '166', 'GT', 'Spider', 'GTV', '145', '146'],
    'Aston Martin': ['DB11', 'Vantage', 'DBS', 'DBX', 'Rapide', 'Vanquish'],
    'Bentley': ['Continental', 'Flying Spur', 'Bentayga', 'Mulsanne'],
    'Ferrari': ['488', 'F8', 'Roma', 'Portofino', 'SF90', '812', 'GTC4Lusso', 'LaFerrari'],
    'Lamborghini': ['Huracan', 'Aventador', 'Urus', 'Gallardo'],
    'Maserati': ['Ghibli', 'Quattroporte', 'Levante', 'GranTurismo', 'MC20'],
    'McLaren': ['540C', '570S', '720S', 'GT', 'Artura', 'P1', '650S'],
    'Rolls-Royce': ['Ghost', 'Wraith', 'Dawn', 'Cullinan', 'Phantom'],
'Infiniti': ['Q30', 'Q50', 'Q60', 'QX30', 'QX50', 'QX60', 'QX80', 'Q70', 'G35', 'G37', 'M35', 'M37', 'FX35', 'FX45', 'EX35', 'Q45', 'I30', 'I35']
  };

  // Function to update models based on selected make in listing form
  // Make sure this is assigned to window so it's globally accessible
  window.updateListingModels = function() {
    console.log('=== updateListingModels function called ===');
    const makeSelect = document.getElementById('listing_make');
    const modelSelect = document.getElementById('listing_model');
    
    if (!makeSelect || !modelSelect) {
      console.warn('Make or model select element not found');
      return;
    }
    
    // Get the selected make value
    const selectedMakeValue = makeSelect.value;
    const selectedMakeText = makeSelect.options[makeSelect.selectedIndex]?.text || '';
    const currentModel = modelSelect.value; // Preserve current selection if editing
    
    console.log('updateListingModels called - Make value:', selectedMakeValue, 'Make text:', selectedMakeText);
    
    // Clear existing options
    modelSelect.innerHTML = '<option value="">Select Model</option>';
    
    // If no make is selected or it's the "All Makes" option, clear model dropdown
    if (!selectedMakeValue || selectedMakeValue === '' || selectedMakeText === 'All Makes') {
      console.log('No make selected or "All Makes" selected, clearing models');
      modelSelect.value = '';
      return;
    }
    
    // Use the value (which should match the carModels keys)
    const selectedMake = selectedMakeValue;
    
    // Check if make exists in carModels (use window.carModels for global access)
    const modelsData = window.carModels;
    if (!modelsData) {
      console.error('carModels object not found!');
      return;
    }
    
    console.log('Looking for make:', selectedMake);
    console.log('Available makes in carModels:', Object.keys(modelsData));
    
    // Try exact match first
    let models = modelsData[selectedMake];
    
    // If not found, try case-insensitive match
    if (!models) {
      const foundKey = Object.keys(modelsData).find(function(key) {
        return key.toLowerCase() === selectedMake.toLowerCase();
      });
      if (foundKey) {
        models = modelsData[foundKey];
        console.log('Found make with case-insensitive match:', foundKey);
      } else {
        // Try matching by text if value doesn't match
        const foundByText = Object.keys(modelsData).find(function(key) {
          return key.toLowerCase() === selectedMakeText.toLowerCase();
        });
        if (foundByText) {
          models = modelsData[foundByText];
          console.log('Found make by matching text:', foundByText);
        }
      }
    }
    
    if (models && Array.isArray(models) && models.length > 0) {
      console.log('✓ Found models for make:', selectedMake, 'Models:', models);
      // Add models for selected make
      models.forEach(function(model) {
        const option = document.createElement('option');
        option.value = model;
        option.textContent = model;
        modelSelect.appendChild(option);
      });
      console.log('✓ Added', models.length, 'models to dropdown');
      
      // If editing and current model exists in the list, restore it
      if (currentModel) {
        const modelOption = Array.from(modelSelect.options).find(opt => opt.value === currentModel);
        if (modelOption) {
          modelSelect.value = currentModel;
          console.log('✓ Restored current model:', currentModel);
        }
      }
    } else {
      console.error('✗ No models found for make:', selectedMake);
      console.error('Make value was:', selectedMakeValue, 'Make text was:', selectedMakeText);
      console.error('Available makes in carModels:', Object.keys(modelsData));
      // Add a generic option if no models
      const option = document.createElement('option');
      option.value = 'Other';
      option.textContent = 'Other';
      modelSelect.appendChild(option);
    }
    console.log('=== updateListingModels function finished ===');
  };
  
  // Vehicle registration lookup
  document.addEventListener('DOMContentLoaded', function() {
    // Show category fields on page load (important for edit forms)
    showCategoryFields();
    
    // Also check after a small delay to ensure DOM is fully ready
    setTimeout(showCategoryFields, 100);
  });
  
  // Also handle Turbo navigation
  document.addEventListener('turbo:load', function() {
    showCategoryFields();
    setTimeout(showCategoryFields, 100);
  });
  
  document.addEventListener('turbo:render', function() {
    showCategoryFields();
  });
  
  document.addEventListener('DOMContentLoaded', function() {
    
    // Initialize model dropdown based on make selection
    const makeSelect = document.getElementById('listing_make');
    const modelSelect = document.getElementById('listing_model');
    
    if (makeSelect && modelSelect) {
      // Update models when make changes
      makeSelect.addEventListener('change', function(e) {
        e.preventDefault();
        e.stopPropagation();
        if (window.updateListingModels) {
          window.updateListingModels();
        }
      });
      
      // Also listen for input event (for programmatic changes)
      makeSelect.addEventListener('input', function() {
        if (window.updateListingModels) {
          window.updateListingModels();
        }
      });
      
      // If editing and make is already selected, populate models immediately
      if (makeSelect.value) {
        console.log('Make already selected on page load:', makeSelect.value);
        if (window.updateListingModels) {
          window.updateListingModels();
        } else {
          console.error('updateListingModels function not available!');
        }
      }
      
      // Also try after a short delay to catch any edge cases
      setTimeout(function() {
        if (makeSelect.value && modelSelect.options.length <= 1) {
          console.log('Retrying model update after delay, make:', makeSelect.value);
          if (window.updateListingModels) {
            window.updateListingModels();
          } else {
            console.error('updateListingModels function still not available!');
          }
        }
      }, 200);
      
      // One more retry after a longer delay to ensure it works
      setTimeout(function() {
        if (makeSelect.value && modelSelect.options.length <= 1) {
          console.log('Final retry for model update, make:', makeSelect.value);
          if (window.updateListingModels) {
            window.updateListingModels();
          }
        }
      }, 500);
    } else {
      console.error('Could not find listing_make or listing_model elements');
    }
    
    const lookupBtn = document.getElementById('lookup_registration_btn');
    const lookupInput = document.getElementById('vehicle_registration_lookup');
    const statusDiv = document.getElementById('lookup_status');
    
    if (lookupBtn && lookupInput) {
      lookupBtn.addEventListener('click', function() {
        const registration = lookupInput.value.trim().toUpperCase().replace(/\s+/g, '');
        
        if (!registration) {
          statusDiv.innerHTML = '<p style="color: #EF4444;">Please enter a registration number</p>';
          statusDiv.style.display = 'block';
          return;
        }
        
        // Show loading state
        lookupBtn.disabled = true;
        lookupBtn.textContent = 'Looking up...';
        statusDiv.innerHTML = '<p style="color: #4FD1A5;">Looking up vehicle details...</p>';
        statusDiv.style.display = 'block';
        
        // Call lookup API
        const csrfToken = document.querySelector('meta[name="csrf-token"]');
        if (!csrfToken) {
          statusDiv.innerHTML = '<p style="color: #EF4444;">Error: CSRF token not found. Please refresh the page.</p>';
          statusDiv.style.display = 'block';
          lookupBtn.disabled = false;
          lookupBtn.textContent = 'Lookup';
          return;
        }
        
        fetch('/vehicle_lookup', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken.content,
            'Accept': 'application/json'
          },
          credentials: 'same-origin',
          body: JSON.stringify({ registration: registration })
        })
        .then(response => {
          if (!response.ok) {
            return response.json().then(err => { throw err; });
          }
          return response.json();
        })
        .then(data => {
          if (data.success && data.data) {
            // Store registration (private)
            const regField = document.getElementById('listing_vehicle_registration');
            if (regField) {
              regField.value = registration;
            }
            
            // Auto-fill basic fields
            const makeSelect = document.getElementById('listing_make');
            if (makeSelect && data.data.make) {
              makeSelect.value = data.data.make;
              // Update models for the selected make
              if (window.updateListingModels) {
                window.updateListingModels();
              }
            }
            
            const modelSelect = document.getElementById('listing_model');
            if (modelSelect && data.data.model) {
              // Wait a bit for model options to populate
              setTimeout(() => {
                modelSelect.value = data.data.model;
              }, 100);
            }
            
            const yearSelect = document.getElementById('listing_year');
            if (yearSelect && data.data.year) {
              yearSelect.value = data.data.year;
            }
            
            const engineSizeInput = document.getElementById('listing_engine_size');
            if (engineSizeInput && data.data.engine_size) {
              engineSizeInput.value = data.data.engine_size;
            }
            
            const fuelTypeSelect = document.getElementById('listing_fuel_type');
            if (fuelTypeSelect && data.data.fuel_type) {
              fuelTypeSelect.value = data.data.fuel_type;
            }
            
            const transmissionSelect = document.getElementById('listing_transmission');
            if (transmissionSelect && data.data.transmission) {
              transmissionSelect.value = data.data.transmission;
            }
            
            // Store detailed data in hidden fields
            const perfField = document.getElementById('listing_performance');
            const dimField = document.getElementById('listing_dimensions');
            const featField = document.getElementById('listing_features');
            const costField = document.getElementById('listing_running_costs');
            
            if (perfField && data.data.performance) {
              perfField.value = JSON.stringify(data.data.performance);
            }
            if (dimField && data.data.dimensions) {
              dimField.value = JSON.stringify(data.data.dimensions);
            }
            if (featField && data.data.features) {
              featField.value = JSON.stringify(data.data.features);
            }
            if (costField && data.data.running_costs) {
              costField.value = JSON.stringify(data.data.running_costs);
            }
            
            statusDiv.innerHTML = '<p style="color: #22C55E;">✓ Vehicle details loaded successfully!</p>';
            setTimeout(() => {
              statusDiv.style.display = 'none';
            }, 3000);
          } else {
            statusDiv.innerHTML = '<p style="color: #EF4444;">' + (data.error || 'Vehicle not found. Please enter details manually.') + '</p>';
          }
        })
        .catch(error => {
          console.error('Error:', error);
          const errorMsg = error.error || error.message || 'Error looking up vehicle. Please enter details manually.';
          statusDiv.innerHTML = '<p style="color: #EF4444;">' + errorMsg + '</p>';
        })
        .finally(() => {
          lookupBtn.disabled = false;
          lookupBtn.textContent = 'Lookup';
        });
      });
      
      // Allow Enter key to trigger lookup
      lookupInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          lookupBtn.click();
        }
      });
    }

    // Image upload and preview functionality
    // Make imageFiles accessible globally for updateUploadZoneVisibility
    window.imageFiles = window.imageFiles || [];
    let imageFiles = window.imageFiles;
    let imageFileIdCounter = 0; // Unique ID counter for each file
    const MAX_IMAGES = 10;
    window.processingFiles = false; // Global flag to prevent duplicate processing
    
    // Get DOM elements (will be refreshed on Turbo navigation)
    const imagePreviewContainer = document.getElementById('image-preview-container');
    const imagePreviewGrid = document.getElementById('image-preview-grid');
    const imageOrderInput = document.getElementById('image-order');

    function processFiles(files) {
      if (!files || files.length === 0) return;
      if (window.processingFiles) {
        console.log('Already processing files, skipping duplicate call');
        return;
      }
      
      window.processingFiles = true;
      
      // Limit to MAX_IMAGES
      const filesToProcess = Array.from(files);
      
      // Filter and add files while preserving the EXACT FileList order.
      // IMPORTANT: we no longer block "duplicates" by name/size so the user can
      // re-upload the same photo in the SAME edit session and still see it in the preview.
      const newFiles = [];
      
      filesToProcess.forEach(function(file, originalIndex) {
        if (file.type.startsWith('image/')) {
          // Check file extension
          const fileName = file.name.toLowerCase();
          const validExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp'];
          const hasValidExtension = validExtensions.some(ext => fileName.endsWith(ext));
          
          if (hasValidExtension) {
            file._uniqueId = 'img_' + (imageFileIdCounter++);
            file._originalIndex = originalIndex;
            file._selectionOrder = originalIndex;
            newFiles.push(file);
          }
        }
      });

      // Add to existing files (up to MAX_IMAGES)
      const remainingSlots = MAX_IMAGES - imageFiles.length;
      const filesToAdd = newFiles.slice(0, remainingSlots);
      imageFiles = imageFiles.concat(filesToAdd);
      // Update global reference
      window.imageFiles = imageFiles;
      
      // Reset processing flag
      setTimeout(function() {
        window.processingFiles = false;
      }, 300);

      // Add new files directly to bottom grid
      addNewFilesToGrid(filesToAdd);
      updateImageOrder();
      updateFileInput();
      
      // Get upload zone element
      const imageUploadZone = document.getElementById('image-upload-zone');
      
      // Upload zone visibility is handled by counting total images in grid
      
      // Always show upload zone when editing (even with existing images)
      // Count existing images if any (including new placeholders)
      const existingThumbnails = document.getElementById('image-thumbnails-grid');
      if (existingThumbnails && imageUploadZone) {
        const existingCount = existingThumbnails.querySelectorAll('.image-thumbnail-item:not([data-removed="true"]):not([style*="opacity: 0.5"]), .new-image-placeholder:not([data-removed="true"]):not([style*="opacity: 0.5"])').length;
        if (existingCount < MAX_IMAGES) {
          imageUploadZone.style.display = 'flex';
        } else {
          imageUploadZone.style.display = 'none';
        }
      }
    }

    // Function to setup image upload event listeners - make it globally accessible
    window.setupImageUploadListeners = function() {
      const imageUploadInput = document.getElementById('image-upload-input');
      const imageUploadZone = document.getElementById('image-upload-zone');
      
      if (!imageUploadInput || !imageUploadZone) {
        console.log('Image upload elements not found, skipping listener setup');
        return;
      }
      
      // Check if already set up to prevent duplicates
      if (imageUploadZone.hasAttribute('data-upload-listeners-setup')) {
        console.log('Upload listeners already set up, removing old ones and re-setting up...');
        // Remove the flag to allow re-setup
        imageUploadZone.removeAttribute('data-upload-listeners-setup');
      }
      imageUploadZone.setAttribute('data-upload-listeners-setup', 'true');
      
      // Make the input cover the entire zone and handle clicks directly
      imageUploadInput.style.position = 'absolute';
      imageUploadInput.style.top = '0';
      imageUploadInput.style.left = '0';
      imageUploadInput.style.width = '100%';
      imageUploadInput.style.height = '100%';
      imageUploadInput.style.opacity = '0';
      imageUploadInput.style.cursor = 'pointer';
      imageUploadInput.style.zIndex = '10';
      imageUploadInput.style.display = 'block'; // Make sure it's visible (but transparent)
      
      // Make content pointer-events none so clicks pass through to input
      const uploadContent = imageUploadZone.querySelector('.upload-zone-content');
      if (uploadContent) {
        uploadContent.style.pointerEvents = 'none'; // Let clicks pass through to input
      }
      
      // No need for zone click handler - the input handles it directly
      
      // File input change - use global flag to prevent duplicate processing
      const newChangeHandler = function(e) {
        if (window.processingFiles) {
          console.log('Already processing files, skipping...');
          e.target.value = '';
          return;
        }
        
        if (e.target.files && e.target.files.length > 0) {
          processFiles(e.target.files);
          // Clear the input so the same file can be selected again if needed
          e.target.value = '';
        }
      };
      
      // Remove old listener by cloning the input
      const oldInput = imageUploadInput;
      const newInput = oldInput.cloneNode(true);
      oldInput.parentNode.replaceChild(newInput, oldInput);
      const freshInput = document.getElementById('image-upload-input');
      
      // Re-apply styles to the new input
      if (freshInput) {
        freshInput.style.position = 'absolute';
        freshInput.style.top = '0';
        freshInput.style.left = '0';
        freshInput.style.width = '100%';
        freshInput.style.height = '100%';
        freshInput.style.opacity = '0';
        freshInput.style.cursor = 'pointer';
        freshInput.style.zIndex = '10';
        freshInput.style.display = 'block';
        
        // Add the new listener
        freshInput.addEventListener('change', newChangeHandler);
      } else {
        // Fallback if cloning didn't work
        imageUploadInput.addEventListener('change', newChangeHandler);
      }
      
      // Drag and drop functionality - remove old listeners first
      const zoneDragOver = function(e) {
        e.preventDefault();
        e.stopPropagation();
        imageUploadZone.classList.add('drag-over');
      };
      const zoneDragLeave = function(e) {
        e.preventDefault();
        e.stopPropagation();
        imageUploadZone.classList.remove('drag-over');
      };
      const zoneDrop = function(e) {
        e.preventDefault();
        e.stopPropagation();
        imageUploadZone.classList.remove('drag-over');
        
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
          processFiles(e.dataTransfer.files);
        }
      };
      
      // Remove old listeners
      imageUploadZone.removeEventListener('dragover', zoneDragOver);
      imageUploadZone.removeEventListener('dragleave', zoneDragLeave);
      imageUploadZone.removeEventListener('drop', zoneDrop);
      
      // Add new listeners
      imageUploadZone.addEventListener('dragover', zoneDragOver);
      imageUploadZone.addEventListener('dragleave', zoneDragLeave);
      imageUploadZone.addEventListener('drop', zoneDrop);
      
      console.log('Image upload listeners set up successfully');
    };
    
    // Setup listeners initially - wait for DOM to be ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        if (typeof window.setupImageUploadListeners === 'function') {
          window.setupImageUploadListeners();
        }
      });
    } else {
      // DOM is already ready
      if (typeof window.setupImageUploadListeners === 'function') {
        window.setupImageUploadListeners();
      }
    }

    // Function to add new files directly to the bottom grid
    function addNewFilesToGrid(newFiles) {
      const existingImageGrid = document.getElementById('image-thumbnails-grid');
      if (!existingImageGrid) {
        console.error('Existing image grid not found');
        return;
      }

      newFiles.forEach(function(file) {
        // Create placeholder in the existing images grid
        const placeholder = document.createElement('div');
        placeholder.className = 'image-thumbnail-item new-image-placeholder image-item';
        placeholder.setAttribute('draggable', 'true');
        placeholder.dataset.fileId = file._uniqueId;
        placeholder.dataset.isNew = 'true';
        placeholder.dataset.isExisting = 'false';
        
        // Create preview from file
        const reader = new FileReader();
        reader.onload = function(e) {
          placeholder.innerHTML = `
            <img src="${e.target.result}" class="thumbnail-image" draggable="false">
            <button type="button" class="remove-thumbnail-image" data-file-id="${file._uniqueId}" title="Remove image">×</button>
            <span class="new-image-badge">NEW</span>
          `;
          
          // Insert at the end of existing images grid
          existingImageGrid.appendChild(placeholder);
          
          // Setup drag handlers for the new placeholder
          if (typeof setupPlaceholderDragHandlers === 'function') {
            setupPlaceholderDragHandlers(placeholder, file);
          }
          
          // Update combined order
          if (typeof updateCombinedImageOrder === 'function') {
            updateCombinedImageOrder();
          }
          
          // Update existing image indices (for COVER badge)
          if (typeof updateExistingImageIndices === 'function') {
            updateExistingImageIndices();
          }
          
          // Update upload zone visibility
          if (typeof updateUploadZoneVisibility === 'function') {
            updateUploadZoneVisibility();
          }
        };
        reader.readAsDataURL(file);
      });
    }

    function updateImagePreview() {
      // This function is no longer needed since we add directly to grid
      // But keep it for backward compatibility with other code that might call it
      return;
      
      // Also add dragover handler to the container for better drag handling
      // Always re-setup to ensure handlers are fresh
      imagePreviewGrid.setAttribute('data-container-drag-setup', 'true');
      
      const previewContainerDragOver = function(e) {
        e.preventDefault();
        e.stopPropagation();
        if (window.draggedElement) {
          e.dataTransfer.dropEffect = 'move';
        }
      };
      const previewContainerDrop = function(e) {
        e.preventDefault();
        e.stopPropagation();
      };
      
      // Remove old listeners
      imagePreviewGrid.removeEventListener('dragover', previewContainerDragOver);
      imagePreviewGrid.removeEventListener('drop', previewContainerDrop);
      
      // Add new listeners
      imagePreviewGrid.addEventListener('dragover', previewContainerDragOver, false);
      imagePreviewGrid.addEventListener('drop', previewContainerDrop, false);
      
      // Check total images (new + existing) before hiding upload zone
      const imageUploadZone = document.getElementById('image-upload-zone');
      const existingThumbnails = document.getElementById('image-thumbnails-grid');
      let existingCount = 0;
      if (existingThumbnails) {
        existingCount = existingThumbnails.querySelectorAll('.image-thumbnail-item:not([data-removed="true"]):not([style*="opacity: 0.5"])').length;
      }
      const totalImages = imageFiles.length + existingCount;
      
      if (imageUploadZone && totalImages >= MAX_IMAGES) {
        imageUploadZone.style.display = 'none';
      } else if (imageUploadZone) {
        imageUploadZone.style.display = 'flex';
      }

      imageFiles.forEach(function(file, index) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const uniqueId = file._uniqueId || 'img_' + index;
          const isMain = index === 0; // First file (index 0) is always the main/cover picture
          
          const imageItem = document.createElement('div');
          imageItem.className = 'image-preview-item';
          imageItem.setAttribute('draggable', 'true');
          imageItem.dataset.index = index;
          imageItem.dataset.fileId = uniqueId;
          imageItem.title = isMain ? 'Cover Picture (Main) - Drag to reorder' : 'Drag to reorder or click star to set as cover';
          imageItem.innerHTML = `
            <img src="${e.target.result}" alt="Preview ${index + 1}" class="preview-image">
            <div class="preview-overlay">
              <div class="preview-left">
                ${isMain ? '<span class="main-badge">COVER</span>' : ''}
                <span class="preview-number">${index + 1}</span>
              </div>
              <div class="preview-right">
                ${!isMain ? '<button type="button" class="set-main-image" data-file-id="${uniqueId}" title="Set as cover picture">⭐</button>' : ''}
                <button type="button" class="remove-preview-image" data-file-id="${uniqueId}" title="Remove image">×</button>
              </div>
            </div>
          `;

          // Drag and drop handlers - simplified and robust
          // Make the item draggable
          imageItem.setAttribute('draggable', 'true');
          
          // Store reference to this item for drag handlers
          const thisItem = imageItem;
          
          // Desktop drag start
          imageItem.addEventListener('dragstart', function(e) {
            // Don't drag if clicking button
            if (e.target.closest('button')) {
              e.preventDefault();
              return false;
            }
            window.draggedElement = thisItem;
            thisItem.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', thisItem.outerHTML);
            e.dataTransfer.setData('text/plain', thisItem.dataset.fileId || '');
            e.dataTransfer.setData('application/json', JSON.stringify({
              type: 'new-image',
              fileId: thisItem.dataset.fileId,
              fileIndex: thisItem.dataset.index
            }));
            console.log('Drag start (new image):', thisItem.dataset.fileId);
          });
          
          // Desktop drag over - CRITICAL: must prevent default
          imageItem.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            if (window.draggedElement && window.draggedElement !== thisItem) {
              const allItems = Array.from(imagePreviewGrid.querySelectorAll('.image-preview-item'));
              const draggedIndex = allItems.indexOf(window.draggedElement);
              const targetIndex = allItems.indexOf(thisItem);
              
              if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
                if (draggedIndex < targetIndex) {
                  imagePreviewGrid.insertBefore(window.draggedElement, thisItem.nextSibling);
                } else {
                  imagePreviewGrid.insertBefore(window.draggedElement, thisItem);
                }
                
                // Update array
                const draggedFile = imageFiles[draggedIndex];
                if (draggedFile) {
                  imageFiles.splice(draggedIndex, 1);
                  imageFiles.splice(targetIndex, 0, draggedFile);
                  window.imageFiles = imageFiles;
                  updateFileInput();
                  updateImageOrder();
                }
              }
            }
          });
          
          // Desktop drag enter
          imageItem.addEventListener('dragenter', function(e) {
            e.preventDefault();
            if (thisItem !== window.draggedElement) {
              thisItem.classList.add('drag-over');
            }
          });
          
          // Desktop drag leave
          imageItem.addEventListener('dragleave', function(e) {
            thisItem.classList.remove('drag-over');
          });
          
          // Desktop drop
          imageItem.addEventListener('drop', function(e) {
            e.preventDefault();
            thisItem.classList.remove('drag-over');
            
            // Final update
            if (window.draggedElement && window.draggedElement !== thisItem) {
              const allItems = Array.from(imagePreviewGrid.querySelectorAll('.image-preview-item'));
              const draggedIndex = allItems.indexOf(window.draggedElement);
              const targetIndex = allItems.indexOf(thisItem);
              
              if (draggedIndex !== -1 && targetIndex !== -1 && draggedIndex !== targetIndex) {
                const draggedFile = imageFiles[draggedIndex];
                if (draggedFile) {
                  imageFiles.splice(draggedIndex, 1);
                  imageFiles.splice(targetIndex, 0, draggedFile);
                  window.imageFiles = imageFiles;
                  updateFileInput();
                  updateImageOrder();
                }
              }
            }
          });
          
          // Desktop drag end
          function finalizeOrderFromDom() {
            // Rebuild array from DOM order
            const reorderedFiles = [];
            const allItemsArray = Array.from(imagePreviewGrid.querySelectorAll('.image-preview-item'));
            allItemsArray.forEach(function(item) {
              const fileId = item.dataset.fileId;
              const file = imageFiles.find(function(f) {
                return (f._uniqueId || '') === fileId;
              });
              if (file) {
                reorderedFiles.push(file);
              }
            });
            
            imageFiles = reorderedFiles;
            window.imageFiles = imageFiles;
            updateImageOrder();
            updateFileInput();
            
            // Don't call updateImagePreview here - it will recreate elements and lose handlers
            // Instead, just update the visual indicators
            setTimeout(function() {
              const allItemsInTimeout = imagePreviewGrid.querySelectorAll('.image-preview-item');
              allItemsInTimeout.forEach(function(item, idx) {
                const leftDiv = item.querySelector('.preview-left');
                const rightDiv = item.querySelector('.preview-right');
                const badge = item.querySelector('.main-badge');
                const setMainBtn = item.querySelector('.set-main-image');
                const numberSpan = item.querySelector('.preview-number');
                
                if (numberSpan) {
                  numberSpan.textContent = idx + 1;
                }
                
                if (idx === 0) {
                  // FIRST IMAGE IS ALWAYS THE MAIN/COVER IMAGE
                  if (!badge && leftDiv) {
                    const newBadge = document.createElement('span');
                    newBadge.className = 'main-badge';
                    newBadge.textContent = 'COVER';
                    leftDiv.insertBefore(newBadge, leftDiv.firstChild);
                  }
                  if (setMainBtn) {
                    setMainBtn.remove();
                  }
                } else {
                  if (badge) {
                    badge.remove();
                  }
                  if (!setMainBtn && rightDiv) {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'set-main-image';
                    btn.setAttribute('data-file-id', item.dataset.fileId || '');
                    btn.title = 'Set as cover picture';
                    btn.textContent = '⭐';
                    btn.style.pointerEvents = 'auto';
                    btn.style.zIndex = '100';
                    btn.style.position = 'relative';
                    btn.addEventListener('click', function(e) {
                      e.stopPropagation();
                      e.preventDefault();
                      e.stopImmediatePropagation();
                      const fileId = this.getAttribute('data-file-id');
                      if (fileId) {
                        setAsMainByFileId(fileId);
                      }
                    });
                    btn.addEventListener('mousedown', function(e) {
                      e.stopPropagation();
                    });
                    rightDiv.insertBefore(btn, rightDiv.querySelector('.remove-preview-image'));
                  }
                }
              });
            }, 10);
          }

          imageItem.addEventListener('dragend', function(e) {
            thisItem.classList.remove('dragging');
            thisItem.classList.remove('drag-over');
            const allItems = imagePreviewGrid.querySelectorAll('.image-preview-item');
            allItems.forEach(function(item) {
              item.classList.remove('drag-over');
            });
            finalizeOrderFromDom();
            window.draggedElement = null;
          });

          // --- Touch support for mobile drag-reorder on new images ---
          let isTouchDraggingPreview = false;

          imageItem.addEventListener('touchstart', function(e) {
            const touch = e.touches && e.touches[0];
            if (!touch) return;
            if (e.target.closest('button')) return;
            window.draggedElement = thisItem;
            isTouchDraggingPreview = true;
            thisItem.classList.add('dragging');
          }, { passive: true });

          imageItem.addEventListener('touchmove', function(e) {
            if (!isTouchDraggingPreview || !window.draggedElement) return;
            // prevent page scroll while reordering
            e.preventDefault();
            const touch = e.touches && e.touches[0];
            if (!touch) return;
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (!target) return;
            const overItem = target.closest('.image-preview-item');
            if (!overItem || overItem === thisItem) return;

            const allItems = Array.from(imagePreviewGrid.querySelectorAll('.image-preview-item'));
            const draggedIndex = allItems.indexOf(thisItem);
            const targetIndex = allItems.indexOf(overItem);
            if (draggedIndex === -1 || targetIndex === -1 || draggedIndex === targetIndex) return;

            if (draggedIndex < targetIndex) {
              imagePreviewGrid.insertBefore(thisItem, overItem.nextSibling);
            } else {
              imagePreviewGrid.insertBefore(thisItem, overItem);
            }

            finalizeOrderFromDom();
          }, { passive: false });

          function endTouchPreviewDrag() {
            if (!isTouchDraggingPreview) return;
            isTouchDraggingPreview = false;
            thisItem.classList.remove('dragging');
            thisItem.classList.remove('drag-over');
          }

          imageItem.addEventListener('touchend', function() {
            endTouchPreviewDrag();
          }, { passive: true });

          imageItem.addEventListener('touchcancel', function() {
            endTouchPreviewDrag();
          }, { passive: true });
          
          // Prevent image drag (browser default) to allow container drag
          const img = imageItem.querySelector('.preview-image');
          if (img) {
            img.setAttribute('draggable', 'false');
            img.style.pointerEvents = 'none';
            img.addEventListener('dragstart', function(e) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }, false);
          }
          
          // Overlay is already set to pointer-events: none in CSS
          // But ensure buttons inside are still clickable
          const overlayForButtons = imageItem.querySelector('.preview-overlay');
          if (overlayForButtons) {
            overlayForButtons.style.pointerEvents = 'none';
            const buttons = overlayForButtons.querySelectorAll('button');
            buttons.forEach(function(btn) {
              btn.style.pointerEvents = 'auto';
              btn.style.zIndex = '100';
              btn.style.position = 'relative';
            });
          }

          // Remove button handler - use file ID for reliable removal
          const removeBtn = imageItem.querySelector('.remove-preview-image');
          if (removeBtn) {
            removeBtn.style.pointerEvents = 'auto';
            removeBtn.style.zIndex = '100';
            removeBtn.addEventListener('click', function(e) {
              e.stopPropagation();
              e.preventDefault();
              e.stopImmediatePropagation();
              const fileId = this.getAttribute('data-file-id');
              console.log('Remove button clicked, fileId:', fileId);
              if (fileId) {
                removeImageByFileId(fileId);
              } else {
                // Fallback to index if file ID not found
                const itemIndex = parseInt(imageItem.dataset.index);
                if (!isNaN(itemIndex)) {
                  removeImage(itemIndex);
                }
              }
            }, true); // Use capture phase
            // Prevent drag on buttons
            removeBtn.addEventListener('mousedown', function(e) {
              e.stopPropagation();
            }, true);
            removeBtn.addEventListener('dragstart', function(e) {
              e.preventDefault();
              e.stopPropagation();
            }, true);
          }

          // Set as main button handler - use file ID for reliable operation
          const setMainBtn = imageItem.querySelector('.set-main-image');
          if (setMainBtn) {
            setMainBtn.addEventListener('click', function(e) {
              e.stopPropagation();
              e.preventDefault();
              e.stopImmediatePropagation();
              const fileId = this.getAttribute('data-file-id');
              if (fileId) {
                setAsMainByFileId(fileId);
              } else {
                // Fallback to index if file ID not found
                const itemIndex = parseInt(imageItem.dataset.index);
                if (!isNaN(itemIndex)) {
                  setAsMain(itemIndex);
                }
              }
            });
            // Prevent drag on buttons
            setMainBtn.addEventListener('mousedown', function(e) {
              e.stopPropagation();
            });
          }

          imagePreviewGrid.appendChild(imageItem);
        };
        reader.readAsDataURL(file);
      });
    }

    function removeImageByFileId(fileId) {
      const fileIndex = imageFiles.findIndex(function(file) {
        return (file._uniqueId || '') === fileId;
      });
      
      if (fileIndex === -1) {
        console.warn('File not found with ID:', fileId);
        return;
      }
      
      imageFiles.splice(fileIndex, 1);
      // Update global reference
      window.imageFiles = imageFiles;
      updateImagePreview();
      updateImageOrder();
      updateFileInput();
      
      // Show upload zone again if under max (checking both new and existing images)
      const imageUploadZone = document.getElementById('image-upload-zone');
      const existingThumbnails = document.getElementById('image-thumbnails-grid');
      let existingCount = 0;
      if (existingThumbnails) {
        existingCount = existingThumbnails.querySelectorAll('.image-thumbnail-item:not([data-removed="true"]):not([style*="opacity: 0.5"])').length;
      }
      const totalImages = imageFiles.length + existingCount;
      
      if (totalImages < MAX_IMAGES && imageUploadZone) {
        imageUploadZone.style.display = 'flex';
      }
    }

    function removeImage(index) {
      if (index >= 0 && index < imageFiles.length) {
        imageFiles.splice(index, 1);
        // Update global reference
        window.imageFiles = imageFiles;
        updateImagePreview();
        updateImageOrder();
        updateFileInput();
        
        // Show upload zone again if under max (checking both new and existing images)
        const imageUploadZone = document.getElementById('image-upload-zone');
        const existingThumbnails = document.getElementById('image-thumbnails-grid');
        let existingCount = 0;
        if (existingThumbnails) {
          existingCount = existingThumbnails.querySelectorAll('.image-thumbnail-item:not([data-removed="true"]):not([style*="opacity: 0.5"])').length;
        }
        const totalImages = imageFiles.length + existingCount;
        
        if (totalImages < MAX_IMAGES && imageUploadZone) {
          imageUploadZone.style.display = 'flex';
        }
      }
    }

    function setAsMainByFileId(fileId) {
      const fileIndex = imageFiles.findIndex(function(file) {
        return (file._uniqueId || '') === fileId;
      });
      
      if (fileIndex === -1 || fileIndex === 0) {
        return;
      }
      
      // Move the selected image to the first position
      const file = imageFiles[fileIndex];
      imageFiles.splice(fileIndex, 1);
      imageFiles.unshift(file);
      
      updateImagePreview();
      updateImageOrder();
      updateFileInput();
    }

    function setAsMain(index) {
      // Fallback method using index
      if (index === 0 || index >= imageFiles.length) return;
      
      // Move the selected image to the first position
      const file = imageFiles[index];
      imageFiles.splice(index, 1);
      imageFiles.unshift(file);
      
      updateImagePreview();
      updateImageOrder();
      updateFileInput();
    }

    function updateFileInput() {
      // Get the input element dynamically to work with Turbo
      const imageUploadInput = document.getElementById('image-upload-input');
      if (!imageUploadInput) {
        console.warn('imageUploadInput not found in updateFileInput');
        return;
      }

      // Ensure imageFiles is defined and is an array
      if (!imageFiles || !Array.isArray(imageFiles)) {
        // Clear the input if no files
        imageUploadInput.files = new DataTransfer().files;
        return;
      }

      // Create a new DataTransfer object to update the file input
      // CRITICAL: Preserve the exact order from imageFiles array
      // The first file in imageFiles is the main/cover picture
      const dataTransfer = new DataTransfer();
      
      // Add files in the EXACT order they appear in imageFiles array
      // This preserves the selection order - first selected = first in array = main picture
      imageFiles.forEach(function(file, index) {
        try {
          dataTransfer.items.add(file);
        } catch (e) {
          console.warn('Could not add file to DataTransfer:', e);
        }
      });
      
      // Update the file input with the ordered files
      imageUploadInput.files = dataTransfer.files;
      
      // Verify order is preserved
      if (imageFiles.length > 0 && dataTransfer.files.length > 0) {
        const firstFile = imageFiles[0];
        const firstInInput = dataTransfer.files[0];
        if (firstFile.name !== firstInInput.name) {
          console.warn('File order mismatch detected!');
        }
      }
    }

    function updateImageOrder() {
      if (imageOrderInput && imageFiles && imageFiles.length > 0) {
        // Store the order as indices (0, 1, 2, ...)
        // The order of imageFiles array IS the order we want
        const order = imageFiles.map(function(file, index) {
          return index;
        }).join(',');
        imageOrderInput.value = order;
        console.log('Updated new image order:', order, 'File count:', imageFiles.length);
      } else if (imageOrderInput) {
        // Clear if no files
        imageOrderInput.value = '';
      }
    }

    // Drag handlers are now inline in updateImagePreview for better reliability

    // Handle existing image removal and reordering (for edit mode)
    // Setup function that works immediately
    function setupExistingImageHandlers() {
      let existingImageGrid = document.getElementById('image-thumbnails-grid');
      if (!existingImageGrid) {
        // Retry after a short delay if grid not found yet (for dynamically loaded content)
        setTimeout(setupExistingImageHandlers, 100);
        return;
      }
      
      console.log('Setting up drag handlers for existing images...');
      console.log('Grid element:', existingImageGrid);
      
      // Check if handlers are already set up to avoid duplicates
      const handlersAlreadySetup = existingImageGrid.hasAttribute('data-drag-handlers-setup');
      if (handlersAlreadySetup) {
        console.log('Drag handlers already set up, skipping to prevent duplication');
        return;
      }
      
      // Mark as set up
      existingImageGrid.setAttribute('data-drag-handlers-setup', 'true');
      
      // Setup drag and drop for existing images
      const existingItems = existingImageGrid.querySelectorAll('.existing-image-item:not([style*="opacity: 0.5"]), .image-thumbnail-item:not([style*="opacity: 0.5"])');
      let draggedExistingItem = null;
      
      // Also add container-level drag handlers
      existingImageGrid.setAttribute('data-container-drag-setup', 'true');
      
      // Make all items draggable - refresh the list to include any dynamically added items
      const allDraggableItems = existingImageGrid.querySelectorAll('.existing-image-item:not([style*="opacity: 0.5"]), .image-thumbnail-item:not([style*="opacity: 0.5"]), .new-image-placeholder:not([style*="opacity: 0.5"])');
      allDraggableItems.forEach(function(item) {
        item.setAttribute('draggable', 'true');
        
        // Prevent image and button from interfering with drag
        const img = item.querySelector('img');
        if (img) {
          img.setAttribute('draggable', 'false');
        }
        const buttons = item.querySelectorAll('button');
        buttons.forEach(function(btn) {
          btn.setAttribute('draggable', 'false');
        });
      });

      // --- Touch support for mobile drag-reorder on existing images ---
      let touchDragItem = null;
      let isTouchDragging = false;

      function reorderItemsForTouch(dragItem, overItem) {
        if (!dragItem || !overItem || dragItem === overItem) return;
        const items = Array.from(existingImageGrid.querySelectorAll('.existing-image-item:not([data-removed="true"]), .image-thumbnail-item:not([data-removed="true"]), .new-image-placeholder:not([data-removed="true"])'));
        const draggedIndex = items.indexOf(dragItem);
        const targetIndex = items.indexOf(overItem);
        if (draggedIndex === -1 || targetIndex === -1 || draggedIndex === targetIndex) return;

        if (draggedIndex < targetIndex) {
          existingImageGrid.insertBefore(dragItem, overItem.nextSibling);
        } else {
          existingImageGrid.insertBefore(dragItem, overItem);
        }

        // Update order/indices after DOM change
        if (typeof window.updateCombinedImageOrder === 'function') {
          window.updateCombinedImageOrder();
        }
        if (typeof window.updateExistingImageOrder === 'function') {
          window.updateExistingImageOrder();
        }
        if (typeof window.updateExistingImageIndices === 'function') {
          window.updateExistingImageIndices();
        }
      }

      existingImageGrid.addEventListener('touchstart', function(e) {
        const item = e.target.closest('.existing-image-item, .image-thumbnail-item, .new-image-placeholder');
        if (!item || item.hasAttribute('data-removed')) return;
        if (e.target.closest('button')) return;
        touchDragItem = item;
        isTouchDragging = true;
        item.classList.add('dragging');
      }, { passive: true });

      existingImageGrid.addEventListener('touchmove', function(e) {
        if (!isTouchDragging || !touchDragItem) return;
        // We need to prevent default to stop the page from scrolling while reordering
        e.preventDefault();
        const touch = e.touches && e.touches[0];
        if (!touch) return;
        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!target) return;
        const overItem = target.closest('.existing-image-item, .image-thumbnail-item, .new-image-placeholder');
        if (!overItem || overItem === touchDragItem) return;
        reorderItemsForTouch(touchDragItem, overItem);
      }, { passive: false });

      function endTouchDrag() {
        if (touchDragItem) {
          touchDragItem.classList.remove('dragging');
        }
        touchDragItem = null;
        isTouchDragging = false;
      }

      existingImageGrid.addEventListener('touchend', function() {
        endTouchDrag();
      }, { passive: true });

      existingImageGrid.addEventListener('touchcancel', function() {
        endTouchDrag();
      }, { passive: true });
      
      console.log('Set up drag handlers for', allDraggableItems.length, 'items');
      
      // Add .image-item class to all items for consistent selection
      const allItems = existingImageGrid.querySelectorAll('.existing-image-item, .image-thumbnail-item, .new-image-placeholder');
      allItems.forEach(function(item) {
        item.classList.add('image-item');
      });
      
      // Container for removed image IDs
      let removedImagesContainer = document.getElementById('removed-images-container');
      if (!removedImagesContainer) {
        removedImagesContainer = document.createElement('div');
        removedImagesContainer.id = 'removed-images-container';
        removedImagesContainer.style.display = 'none';
        const formEl = document.querySelector('form');
        if (formEl) {
          formEl.appendChild(removedImagesContainer);
        } else {
          const formField = document.querySelector('.form-field');
          if (formField && formField.parentElement) {
            formField.parentElement.appendChild(removedImagesContainer);
          } else if (imageUploadInput && imageUploadInput.parentElement) {
            imageUploadInput.parentElement.appendChild(removedImagesContainer);
          }
        }
      }
      
      // Container for image order - use existing or create hidden input for existing image order
      let imageOrderContainer = document.getElementById('existing-image-order-container');
      if (!imageOrderContainer) {
        imageOrderContainer = document.createElement('input');
        imageOrderContainer.type = 'hidden';
        imageOrderContainer.id = 'existing-image-order-container';
        imageOrderContainer.name = 'existing_image_order';
        // Find the form and append to it
        const form = document.querySelector('form');
        if (form) {
          form.appendChild(imageOrderContainer);
        } else {
          // Fallback: append near image upload field
          const formField = document.querySelector('.form-field');
          if (formField && formField.parentElement) {
            formField.parentElement.appendChild(imageOrderContainer);
          } else {
            const imageUploadInput = document.getElementById('image-upload-input');
            if (imageUploadInput && imageUploadInput.parentElement) {
              imageUploadInput.parentElement.appendChild(imageOrderContainer);
            }
          }
        }
      }
      
      // ALWAYS initialize/update the order from DOM, even if it already has a value
      // This ensures the order matches what's actually displayed
      if (imageOrderContainer && existingImageGrid) {
        const items = existingImageGrid.querySelectorAll('.existing-image-item:not([style*="opacity: 0.5"]), .image-thumbnail-item:not([style*="opacity: 0.5"]), .new-image-placeholder:not([style*="opacity: 0.5"])');
        if (items.length > 0) {
          const order = Array.from(items).map(function(item) {
            if (item.classList.contains('new-image-placeholder')) {
              return 'new:' + (item.dataset.fileId || '');
            } else {
              return item.getAttribute('data-image-id');
            }
          }).filter(function(id) { return id; }).join(',');
          imageOrderContainer.value = order;
          console.log('Initialized/updated existing image order:', order);
        }
      }
      
      // CRITICAL: Also initialize combined order from existing images on page load
      // This ensures all existing images are included in the combined order
      if (typeof updateCombinedImageOrder === 'function') {
        // Small delay to ensure DOM is ready
        setTimeout(function() {
          updateCombinedImageOrder();
        }, 50);
      }
      
      // Initialize indices
      updateExistingImageIndices();
      
      // Setup handlers for any existing new-image-placeholder elements
      const existingPlaceholders = existingImageGrid.querySelectorAll('.new-image-placeholder');
      existingPlaceholders.forEach(function(placeholder) {
        const fileId = placeholder.dataset.fileId;
        const file = imageFiles.find(function(f) {
          return (f._uniqueId || '') === fileId;
        });
        if (file && typeof setupPlaceholderDragHandlers === 'function') {
          setupPlaceholderDragHandlers(placeholder, file);
        }
      });
      
      // Initialize combined order - CRITICAL: This must include all existing images
      if (typeof updateCombinedImageOrder === 'function') {
        updateCombinedImageOrder();
        // Also update after a short delay to ensure DOM is fully ready
        setTimeout(function() {
          updateCombinedImageOrder();
        }, 100);
      }
      
      // Handle remove buttons - use event delegation for reliability
      existingImageGrid.addEventListener('click', function(e) {
        const removeBtn = e.target.closest('.remove-thumbnail-image, .remove-existing-image');
        if (!removeBtn) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        const imageItem = removeBtn.closest('.existing-image-item, .image-thumbnail-item, .new-image-placeholder');
        if (!imageItem) {
          console.warn('Could not find image item for remove button');
          return;
        }
        
        const grid = document.getElementById('image-thumbnails-grid');
        if (!grid) {
          console.warn('Image grid not found');
          return;
        }
        
        // Handle removal of new image placeholder
        if (imageItem.classList.contains('new-image-placeholder')) {
          const fileId = removeBtn.getAttribute('data-file-id') || imageItem.dataset.fileId;
          if (fileId) {
            // DOM-first: remove from DOM immediately
            imageItem.remove();
            
            // Remove from imageFiles array if it exists
            if (window.imageFiles && Array.isArray(window.imageFiles)) {
              const fileIndex = window.imageFiles.findIndex(function(f) {
                return f && (f._uniqueId || '') === fileId;
              });
              if (fileIndex !== -1) {
                window.imageFiles.splice(fileIndex, 1);
                if (typeof updateFileInput === 'function') {
                  try {
                    updateFileInput();
                  } catch (err) {
                    console.error('Error in updateFileInput:', err);
                  }
                }
                if (typeof updateImageOrder === 'function') {
                  try {
                    updateImageOrder();
                  } catch (err) {
                    console.error('Error in updateImageOrder:', err);
                  }
                }
              }
            }
            
            // Recompute order from fresh DOM
            if (typeof window.updateCombinedImageOrder === 'function') {
              try {
                window.updateCombinedImageOrder();
              } catch (err) {
                console.error('Error in updateCombinedImageOrder:', err);
              }
            }
            if (typeof window.updateExistingImageIndices === 'function') {
              try {
                window.updateExistingImageIndices();
              } catch (err) {
                console.error('Error in updateExistingImageIndices:', err);
              }
            }
            if (typeof updateUploadZoneVisibility === 'function') {
              try {
                updateUploadZoneVisibility();
              } catch (err) {
                console.error('Error in updateUploadZoneVisibility:', err);
              }
            }
            return;
          }
        }
        
        const imageId = removeBtn.getAttribute('data-image-id');
        if (!imageId) {
          console.warn('No image ID found for remove button');
          return;
        }
        
        // DOM-first: show as deleted but keep visible
        imageItem.style.opacity = '0.3';
        imageItem.style.pointerEvents = 'none';
        imageItem.style.filter = 'grayscale(100%)';
        imageItem.setAttribute('data-removed', 'true');
        
        // Add "DELETED" badge
        let deletedBadge = imageItem.querySelector('.deleted-badge');
        if (!deletedBadge) {
          deletedBadge = document.createElement('span');
          deletedBadge.className = 'deleted-badge';
          deletedBadge.textContent = 'DELETED';
          deletedBadge.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(239, 68, 68, 0.9); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold; font-size: 14px; z-index: 10; pointer-events: none;';
          imageItem.style.position = 'relative';
          imageItem.appendChild(deletedBadge);
        }
        
        // Get or create removed images container
        let container = document.getElementById('removed-images-container');
        if (!container) {
          container = document.createElement('div');
          container.id = 'removed-images-container';
          container.style.display = 'none';
        const formEl = document.querySelector('form');
        if (formEl) {
          formEl.appendChild(container);
        } else {
          const formField = document.querySelector('.form-field');
          if (formField && formField.parentElement) {
            formField.parentElement.appendChild(container);
          } else {
            const imageUploadInput = document.getElementById('image-upload-input');
            if (imageUploadInput && imageUploadInput.parentElement) {
              imageUploadInput.parentElement.appendChild(container);
            }
          }
        }
        }
        
        if (container && !container.querySelector(`input[value="${imageId}"]`)) {
          const removedInput = document.createElement('input');
          removedInput.type = 'hidden';
          removedInput.name = 'removed_image_ids[]';
          removedInput.value = imageId;
          removedInput.setAttribute('data-removed-id', imageId);
          container.appendChild(removedInput);
        }
        
        // Recompute order from fresh DOM
        if (typeof window.updateCombinedImageOrder === 'function') {
          try {
            window.updateCombinedImageOrder();
          } catch (err) {
            console.error('Error in updateCombinedImageOrder:', err);
          }
        }
        if (typeof window.updateExistingImageOrder === 'function') {
          try {
            window.updateExistingImageOrder();
          } catch (err) {
            console.error('Error in updateExistingImageOrder:', err);
          }
        }
        if (typeof window.updateExistingImageIndices === 'function') {
          try {
            window.updateExistingImageIndices();
          } catch (err) {
            console.error('Error in updateExistingImageIndices:', err);
          }
        }
        
        // Update upload zone visibility
        if (typeof updateUploadZoneVisibility === 'function') {
          updateUploadZoneVisibility();
        }
      });
      
      
      // Mark as set up after all handlers are attached
      existingImageGrid.setAttribute('data-drag-handlers-setup', 'true');
      console.log('✓ Drag handlers setup complete for', existingItems.length, 'items');
      
      // Function to setup drag handlers for new image placeholders
      // Since we use event delegation on the grid, we just need to make it draggable
      function setupPlaceholderDragHandlers(placeholder, file) {
        // Make sure it's draggable
        placeholder.setAttribute('draggable', 'true');
        
        // Prevent image and button from interfering
        const img = placeholder.querySelector('img');
        if (img) {
          img.setAttribute('draggable', 'false');
        }
        const buttons = placeholder.querySelectorAll('button');
        buttons.forEach(function(btn) {
          btn.setAttribute('draggable', 'false');
        });
        
        // Store placeholder reference in dragstart (handled by grid-level handler)
        // The grid-level dragstart handler will set window.draggedPlaceholder
        
        // Remove button handler
        const removeBtn = placeholder.querySelector('.remove-thumbnail-image');
        if (removeBtn) {
          removeBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const fileId = this.getAttribute('data-file-id');
            
            // Remove from existing images grid
            placeholder.remove();
            
            // Remove from imageFiles array
            const fileIndex = imageFiles.findIndex(function(f) {
              return (f._uniqueId || '') === fileId;
            });
            if (fileIndex !== -1) {
              imageFiles.splice(fileIndex, 1);
              window.imageFiles = imageFiles;
              updateFileInput();
              updateImageOrder();
            }
            
            // Update combined order and indices
            if (typeof updateCombinedImageOrder === 'function') {
              updateCombinedImageOrder();
            }
            if (typeof updateExistingImageIndices === 'function') {
              updateExistingImageIndices();
            }
            
            // Update upload zone visibility
            if (typeof updateUploadZoneVisibility === 'function') {
              updateUploadZoneVisibility();
            }
          });
        }
      }
      
      // Function to update combined image order (new + existing)
      // MUST be defensive - check all containers and arrays before accessing
      function updateCombinedImageOrder() {
        const grid = document.getElementById('image-thumbnails-grid');
        if (!grid) {
          console.warn('Image grid not found');
          return;
        }
        
        const items = Array.from(grid.querySelectorAll('.existing-image-item, .image-thumbnail-item, .new-image-placeholder')).filter(function(item) {
          // Exclude removed items (check data-removed attribute)
          return item && !item.hasAttribute('data-removed');
        });
        if (!items || items.length === 0) {
          // No items, clear the order
          const combinedOrderInput = document.getElementById('combined-image-order');
          if (combinedOrderInput) {
            combinedOrderInput.value = '';
          }
          return;
        }
        
        const order = [];
        
        // Process items in DOM order (left to right, top to bottom)
        items.forEach(function(item) {
          if (!item) return;
          
          if (item.classList.contains('new-image-placeholder') || item.dataset.isNew === 'true') {
            // New image placeholder
            const fileId = item.dataset.fileId;
            if (fileId) {
              order.push('new:' + fileId);
            }
          } else if (item.classList.contains('existing-image-item') || item.dataset.isExisting === 'true') {
            // Existing image - get the data-image-id attribute
            const imageId = item.getAttribute('data-image-id');
            if (imageId) {
              order.push('existing:' + imageId);
            }
          } else {
            // Fallback: try to get ID from any available attribute
            const imageId = item.getAttribute('data-image-id');
            const fileId = item.dataset.fileId;
            if (imageId) {
              order.push('existing:' + imageId);
            } else if (fileId) {
              order.push('new:' + fileId);
            }
          }
        });
        
        // Guard: ensure order is an array before using
        if (!Array.isArray(order)) {
          console.warn('Order array missing, aborting update');
          return;
        }
        
        const combinedOrderInput = document.getElementById('combined-image-order');
        if (!combinedOrderInput) {
          console.warn('Hidden order input missing');
          return;
        }
        
        const orderString = order.join(',');
        combinedOrderInput.value = orderString;
      }
      
      // Make functions globally accessible
      window.setupExistingImageHandlers = setupExistingImageHandlers;
      window.updateExistingImageOrder = updateExistingImageOrder;
      window.updateExistingImageIndices = updateExistingImageIndices;
      window.updateCombinedImageOrder = updateCombinedImageOrder;
      window.setupPlaceholderDragHandlers = setupPlaceholderDragHandlers;
      
      // Make setupExistingImageHandlers globally accessible
      window.setupExistingImageHandlers = setupExistingImageHandlers;
      
      function updateExistingImageIndices() {
        const items = existingImageGrid.querySelectorAll(
          '.existing-image-item:not([data-removed="true"]):not([style*="opacity: 0.5"]), ' +
          '.image-thumbnail-item:not([data-removed="true"]):not([style*="opacity: 0.5"]), ' +
          '.new-image-placeholder:not([data-removed="true"]):not([style*="opacity: 0.5"])'
        );
        
        // First, remove ALL main badges to start fresh
        items.forEach(function(item) {
          const mainBadge = item.querySelector('.main-badge-existing');
          if (mainBadge) {
            mainBadge.remove();
          }
        });
        
        // Now, add badges based on new order - FIRST IMAGE IS ALWAYS MAIN
        items.forEach(function(item, index) {
          item.setAttribute('data-image-index', index);
          
          // FIRST IMAGE IS ALWAYS THE MAIN/COVER IMAGE (whether new or existing)
          if (index === 0) {
            // Check if it's a new placeholder or existing image
            const isNewPlaceholder = item.classList.contains('new-image-placeholder');
            const badgeClass = isNewPlaceholder ? 'new-image-badge cover-badge' : 'main-badge-existing';
            
            // Remove any existing badges first
            const existingBadge = item.querySelector('.main-badge-existing, .cover-badge');
            if (existingBadge) {
              existingBadge.remove();
            }
            
            // Create COVER badge
            const badge = document.createElement('span');
            badge.className = badgeClass;
            badge.textContent = 'COVER';
            badge.style.cssText = 'position: absolute; top: 4px; left: 4px; background: #22C55E; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; z-index: 10;';
            item.style.position = 'relative';
            item.appendChild(badge);
          }
        });
      }
      
      function updateExistingImageOrder() {
        const container = document.getElementById('existing-image-order-container');
        const grid = document.getElementById('image-thumbnails-grid');
        if (!container || !grid) {
          console.warn('Cannot update existing image order: container or grid not found');
          return;
        }
        const items = grid.querySelectorAll(
          '.existing-image-item:not([data-removed="true"]):not([style*="opacity: 0.5"]), ' +
          '.image-thumbnail-item:not([data-removed="true"]):not([style*="opacity: 0.5"]), ' +
          '.new-image-placeholder:not([data-removed="true"]):not([style*="opacity: 0.5"])'
        );
        if (items.length === 0) {
          container.value = '';
          console.log('No existing images to order');
          return;
        }
        const order = Array.from(items).map(function(item) {
          // For new placeholders, use fileId; for existing, use image-id
          if (item.classList.contains('new-image-placeholder')) {
            return 'new:' + (item.dataset.fileId || '');
          } else {
            const imageId = item.getAttribute('data-image-id');
            if (!imageId) {
              console.warn('Image item missing data-image-id:', item);
            }
            return imageId || '';
          }
        }).filter(function(id) { return id; }).join(',');
        container.value = order;
        console.log('Updated existing image order:', order, 'Item count:', items.length);
      }
      
      // Initialize the existing image order on page load
      // This ensures the order is always sent, even if user doesn't make changes
      if (typeof updateExistingImageOrder === 'function') {
        updateExistingImageOrder();
      }
      
      // Ensure order is ALWAYS updated before form submission
      const form = document.querySelector('form');
      if (form) {
        // Guard against double-submits (which can duplicate images on the server)
        let isListingFormSubmitting = false;

        // Function to sync all orders before submission
        function syncAllImageOrders() {
          // CRITICAL: Rebuild imageFiles array from new-image-placeholder elements in the grid
          // This ensures all new files are included in the submission in the correct order
          const existingImageGrid = document.getElementById('image-thumbnails-grid');
          if (existingImageGrid && typeof window.imageFiles !== 'undefined' && window.imageFiles.length > 0) {
            const newPlaceholders = existingImageGrid.querySelectorAll('.new-image-placeholder:not([style*="opacity: 0.5"])');
            const reorderedFiles = [];
            
            // Get files from placeholders in the order they appear in the grid
            newPlaceholders.forEach(function(placeholder) {
              const fileId = placeholder.dataset.fileId;
              const file = window.imageFiles.find(function(f) {
                return (f._uniqueId || '') === fileId;
              });
              if (file) {
                reorderedFiles.push(file);
              }
            });
            
            // Update imageFiles with the ordered files (preserve any files not in placeholders)
            if (reorderedFiles.length > 0) {
              window.imageFiles = reorderedFiles;
              imageFiles = reorderedFiles;
              console.log('Rebuilt imageFiles from placeholders in grid order:', reorderedFiles.length, 'files');
            }
          }
          
          // CRITICAL: Update file input with current imageFiles (so files are submitted)
          if (typeof updateFileInput === 'function') {
            updateFileInput();
            console.log('Updated file input before submission, file count:', imageFiles ? imageFiles.length : 0);
          }
          
          // Update combined image order (this includes both new and existing) - MOST IMPORTANT
          if (typeof window.updateCombinedImageOrder === 'function') {
            window.updateCombinedImageOrder();
          }
          
          // Also update existing image order for backward compatibility
          if (typeof window.updateExistingImageOrder === 'function') {
            window.updateExistingImageOrder();
          }
          
          // Update image indices to show COVER badge on first image
          if (typeof window.updateExistingImageIndices === 'function') {
            window.updateExistingImageIndices();
          }
          
          // Update new/preview images order (if any remain in preview)
          if (typeof updateImageOrder === 'function') {
            updateImageOrder();
          }
        }
        
        // Update order on form submit (capture phase to run early)
        form.addEventListener('submit', function(e) {
          if (isListingFormSubmitting) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
          isListingFormSubmitting = true;

          // Sync all orders and files FIRST
          syncAllImageOrders();
          
          // Force update file input one more time to ensure files are included
          if (typeof updateFileInput === 'function') {
            updateFileInput();
          }
          
          // CRITICAL: Force update combined image order multiple times to ensure it's set
          if (typeof window.updateCombinedImageOrder === 'function') {
            window.updateCombinedImageOrder();
            // Update again immediately
            window.updateCombinedImageOrder();
          }
          
          // Force update indices to ensure COVER badge is shown
          if (typeof window.updateExistingImageIndices === 'function') {
            window.updateExistingImageIndices();
          }
          
          // Also update existing image order as backup
          if (typeof window.updateExistingImageOrder === 'function') {
            window.updateExistingImageOrder();
          }
          
          // Log everything for debugging
          const combinedOrderInput = document.getElementById('combined-image-order');
          const existingOrderContainer = document.getElementById('existing-image-order-container');
          const newOrderContainer = document.getElementById('image-order');
          const fileInput = document.getElementById('image-upload-input');
          
          console.log('=== FORM SUBMISSION DEBUG ===');
          if (fileInput && fileInput.files) {
            console.log('File input has', fileInput.files.length, 'files');
            for (let i = 0; i < fileInput.files.length; i++) {
              console.log('  File', i, ':', fileInput.files[i].name);
            }
          }
          if (combinedOrderInput) {
            console.log('Combined image order:', combinedOrderInput.value);
            // If it's still empty, try one more time
            if (!combinedOrderInput.value) {
              console.warn('Combined order is empty! Trying to update again...');
              if (typeof window.updateCombinedImageOrder === 'function') {
                window.updateCombinedImageOrder();
              }
            }
          }
          if (existingOrderContainer) {
            console.log('Existing image order:', existingOrderContainer.value);
          }
          if (newOrderContainer) {
            console.log('New image order:', newOrderContainer.value);
          }
          console.log('imageFiles array length:', window.imageFiles ? window.imageFiles.length : 0);
          console.log('===========================');
        }, true);
        
        // Also update order when submit button is clicked (as a backup)
        // IMPORTANT: do NOT mark submitting here; the submit event is the source of truth.
        // Otherwise we can block the real submit in some Turbo/drag flows.
        const submitBtn = document.getElementById('listing-submit-btn');
        if (submitBtn) {
          submitBtn.addEventListener('click', function(e) {
            if (isListingFormSubmitting) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }

            // Update orders immediately (pre-submit)
            syncAllImageOrders();
            if (typeof updateFileInput === 'function') {
              updateFileInput();
            }
            if (typeof window.updateCombinedImageOrder === 'function') {
              window.updateCombinedImageOrder();
              // Update again after a tiny delay
              setTimeout(function() {
                window.updateCombinedImageOrder();
              }, 5);
            }

            // Disable after the click has triggered submission to avoid double clicks,
            // without interfering with the submit event itself.
            setTimeout(function() {
              if (!isListingFormSubmitting) return;
              submitBtn.disabled = true;
              submitBtn.classList.add('btn-disabled');
            }, 0);
          }, true); // Use capture phase
        }
        const submitButton = form.querySelector('input[type="submit"], button[type="submit"]');
        if (submitButton) {
          submitButton.addEventListener('click', function(e) {
            // Small delay to ensure this runs before form submission
            setTimeout(syncAllImageOrders, 10);
          });
        }
      }
      
      
      // Also call the global function as a backup
      if (typeof window.setupExistingImageRemoveHandlers === 'function') {
        window.setupExistingImageRemoveHandlers();
      }
    }
    
    // Call setup function immediately
    try {
      setupExistingImageHandlers();
    } catch (e) {
      console.error('Error in setupExistingImageHandlers:', e);
    }
    
    // Also call after delays to ensure it works even with slow page loads
    setTimeout(function() {
      try {
        setupExistingImageHandlers();
      } catch (e) {
        console.error('Error in setupExistingImageHandlers (100ms):', e);
      }
    }, 100);
    setTimeout(function() {
      try {
        setupExistingImageHandlers();
      } catch (e) {
        console.error('Error in setupExistingImageHandlers (300ms):', e);
      }
    }, 300);
    setTimeout(function() {
      try {
        setupExistingImageHandlers();
      } catch (e) {
        console.error('Error in setupExistingImageHandlers (500ms):', e);
      }
    }, 500);
  });
  
  // Also re-initialize on Turbo navigation
  // Use a flag to prevent multiple simultaneous initializations
  let turboInitializing = false;
  
  function initializeOnTurbo() {
    if (turboInitializing) return;
    turboInitializing = true;
    
    try {
      // Initialize models dropdown
      if (typeof window.updateListingModels === 'function') {
        const makeSelect = document.getElementById('listing_make');
        if (makeSelect && makeSelect.value) {
          setTimeout(function() {
            window.updateListingModels();
          }, 50);
        }
      }
      
      // Initialize image handlers
      if (typeof window.setupExistingImageHandlers === 'function') {
        window.setupExistingImageHandlers();
        setTimeout(function() {
          if (typeof window.setupExistingImageHandlers === 'function') {
            window.setupExistingImageHandlers();
          }
          turboInitializing = false;
        }, 100);
      } else {
        turboInitializing = false;
      }
      
      // Initialize order on Turbo navigation
      if (typeof window.updateExistingImageOrder === 'function') {
        setTimeout(function() {
          if (typeof window.updateExistingImageOrder === 'function') {
            window.updateExistingImageOrder();
          }
        }, 150);
      }
    } catch (e) {
      console.error('Error initializing on Turbo:', e);
      turboInitializing = false;
    }
  }
  
  // Handle thumbnail remove buttons
  function setupThumbnailRemoveButtons() {
    const thumbnailsGrid = document.getElementById('image-thumbnails-grid');
    if (!thumbnailsGrid) return;
    
    // Check if already set up to prevent duplication
    if (thumbnailsGrid.hasAttribute('data-remove-buttons-setup')) {
      return;
    }
    thumbnailsGrid.setAttribute('data-remove-buttons-setup', 'true');
    
    // Don't clone the grid - just set up event delegation
    const freshGrid = thumbnailsGrid;
    
    freshGrid.addEventListener('click', function(e) {
      const removeBtn = e.target.closest('.remove-thumbnail-image');
      if (!removeBtn) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      // Get the image item
      const imageItem = removeBtn.closest('.existing-image-item, .image-thumbnail-item, .new-image-placeholder');
      if (!imageItem) {
        console.warn('Could not find image item for remove button');
        return;
      }
      
      const grid = document.getElementById('image-thumbnails-grid');
      if (!grid) {
        console.warn('Image grid not found');
        return;
      }
      
      // Check if it's a new placeholder (has data-file-id)
      const fileId = removeBtn.getAttribute('data-file-id');
      if (fileId) {
        // DOM-first: remove from DOM immediately
        imageItem.remove();
        
        // Remove from imageFiles array if it exists
        if (window.imageFiles && Array.isArray(window.imageFiles)) {
          const fileIndex = window.imageFiles.findIndex(function(f) {
            return f && (f._uniqueId || '') === fileId;
          });
          if (fileIndex !== -1) {
            window.imageFiles.splice(fileIndex, 1);
            if (typeof updateFileInput === 'function') {
              try {
                updateFileInput();
              } catch (err) {
                console.error('Error in updateFileInput:', err);
              }
            }
            if (typeof updateImageOrder === 'function') {
              try {
                updateImageOrder();
              } catch (err) {
                console.error('Error in updateImageOrder:', err);
              }
            }
          }
        }
        
        // Recompute order from fresh DOM
        if (typeof window.updateCombinedImageOrder === 'function') {
          try {
            window.updateCombinedImageOrder();
          } catch (err) {
            console.error('Error in updateCombinedImageOrder:', err);
          }
        }
        if (typeof window.updateExistingImageIndices === 'function') {
          try {
            window.updateExistingImageIndices();
          } catch (err) {
            console.error('Error in updateExistingImageIndices:', err);
          }
        }
        if (typeof updateUploadZoneVisibility === 'function') {
          try {
            updateUploadZoneVisibility();
          } catch (err) {
            console.error('Error in updateUploadZoneVisibility:', err);
          }
        }
        return;
      }
      
      // Handle existing image removal (has data-image-id)
      const imageId = removeBtn.getAttribute('data-image-id');
      if (!imageId) {
        console.warn('No image ID found for remove button');
        return;
      }
      
      // DOM-first: show as deleted but keep visible
      imageItem.style.opacity = '0.3';
      imageItem.style.pointerEvents = 'none';
      imageItem.style.filter = 'grayscale(100%)';
      imageItem.setAttribute('data-removed', 'true');
      
      // Add "DELETED" badge
      let deletedBadge = imageItem.querySelector('.deleted-badge');
      if (!deletedBadge) {
        deletedBadge = document.createElement('span');
        deletedBadge.className = 'deleted-badge';
        deletedBadge.textContent = 'DELETED';
        deletedBadge.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(239, 68, 68, 0.9); color: white; padding: 8px 16px; border-radius: 4px; font-weight: bold; font-size: 14px; z-index: 10; pointer-events: none;';
        imageItem.style.position = 'relative';
        imageItem.appendChild(deletedBadge);
      }
      
      // Add hidden input for removed image
      let removedContainer = document.getElementById('removed-images-container');
      if (!removedContainer) {
        removedContainer = document.createElement('div');
        removedContainer.id = 'removed-images-container';
        removedContainer.style.display = 'none';
        const form = document.querySelector('form');
        if (form) {
          form.appendChild(removedContainer);
        } else {
          const formSection = document.querySelector('.form-section');
          if (formSection) {
            formSection.appendChild(removedContainer);
          }
        }
      }
      
      if (removedContainer && !removedContainer.querySelector(`input[value="${imageId}"]`)) {
        const removedInput = document.createElement('input');
        removedInput.type = 'hidden';
        removedInput.name = 'removed_image_ids[]';
        removedInput.value = imageId;
        removedContainer.appendChild(removedInput);
      }
      
      // Recompute order from fresh DOM
      if (typeof window.updateCombinedImageOrder === 'function') {
        try {
          window.updateCombinedImageOrder();
        } catch (err) {
          console.error('Error in updateCombinedImageOrder:', err);
        }
      }
      if (typeof window.updateExistingImageOrder === 'function') {
        try {
          window.updateExistingImageOrder();
        } catch (err) {
          console.error('Error in updateExistingImageOrder:', err);
        }
      }
      if (typeof window.updateExistingImageIndices === 'function') {
        try {
          window.updateExistingImageIndices();
        } catch (err) {
          console.error('Error in updateExistingImageIndices:', err);
        }
      }
      if (typeof updateUploadZoneVisibility === 'function') {
        try {
          updateUploadZoneVisibility();
        } catch (err) {
          console.error('Error in updateUploadZoneVisibility:', err);
        }
      }
    }, true); // Use capture phase for better reliability
  }
  
  // Function to update upload zone visibility based on total images
  function updateUploadZoneVisibility() {
    const imageUploadZone = document.getElementById('image-upload-zone');
    if (!imageUploadZone) return;

    // Count all images in the bottom grid (existing + new placeholders)
    const existingThumbnails = document.getElementById('image-thumbnails-grid');
    let totalCount = 0;
    if (existingThumbnails) {
      totalCount = existingThumbnails.querySelectorAll('.image-thumbnail-item:not([data-removed="true"]):not([style*="opacity: 0.5"]), .new-image-placeholder:not([data-removed="true"]):not([style*="opacity: 0.5"])').length;
    }

    const MAX_IMAGES = 10;
    
    if (totalCount >= MAX_IMAGES) {
      imageUploadZone.style.display = 'none';
    } else {
      imageUploadZone.style.display = 'flex';
    }
  }
  
  // Initialize on Turbo events
  document.addEventListener('turbo:load', function() {
    // Reset setup flags to allow re-initialization on navigation
    const thumbnailsGrid = document.getElementById('image-thumbnails-grid');
    if (thumbnailsGrid) {
      thumbnailsGrid.removeAttribute('data-remove-buttons-setup');
    }
    setupThumbnailRemoveButtons();
    // Re-setup image upload listeners on Turbo navigation
    // Use setTimeout to ensure DOM is fully loaded
    setTimeout(function() {
      if (typeof window.setupImageUploadListeners === 'function') {
        // Remove the setup flag to allow re-initialization
        const imageUploadZone = document.getElementById('image-upload-zone');
        const imageUploadInput = document.getElementById('image-upload-input');
        if (imageUploadZone && imageUploadInput) {
          imageUploadZone.removeAttribute('data-upload-listeners-setup');
          window.setupImageUploadListeners();
        } else {
          console.warn('Image upload elements not found on turbo:load');
        }
      }
    }, 50);
    // Reset client-side image selection state on each Turbo load.
    // This prevents "can't re-upload the same file" issues caused by stale window.imageFiles
    // (Turbo can preserve JS globals across navigations).
    window.imageFiles = [];
    imageFiles = window.imageFiles;
    window.processingFiles = false;
    imageFileIdCounter = 0;

    // If Turbo restored cached DOM, remove any stale "new image" placeholders from a previous visit
    const grid = document.getElementById('image-thumbnails-grid');
    if (grid) {
      grid.querySelectorAll('.new-image-placeholder').forEach(function(el) { el.remove(); });
    }

    // Clear any stale removed image inputs from cached DOM
    const removedContainer = document.getElementById('removed-images-container');
    if (removedContainer) {
      removedContainer.innerHTML = '';
    }
    // Setup existing image drag handlers
    if (typeof window.setupExistingImageHandlers === 'function') {
      // Remove setup flag to allow re-initialization
      let existingImageGrid = document.getElementById('image-thumbnails-grid');
      if (existingImageGrid) {
        existingImageGrid.removeAttribute('data-drag-handlers-setup');
        existingImageGrid.removeAttribute('data-container-drag-setup');
      }
      setTimeout(function() {
        window.setupExistingImageHandlers();
        // After handlers are set up, initialize combined order with all existing images
        if (typeof window.updateCombinedImageOrder === 'function') {
          // Update immediately
          window.updateCombinedImageOrder();
          // And again after a delay to ensure it's set
          setTimeout(function() {
            window.updateCombinedImageOrder();
            console.log('Initialized combined order on page load');
          }, 150);
        }
      }, 100);
    }
    // Update upload zone visibility on page load
    setTimeout(updateUploadZoneVisibility, 100);
  });
  
  document.addEventListener('turbo:render', function() {
    // Reset setup flags to allow re-initialization on render
    const thumbnailsGrid = document.getElementById('image-thumbnails-grid');
    if (thumbnailsGrid) {
      thumbnailsGrid.removeAttribute('data-remove-buttons-setup');
    }
    setupThumbnailRemoveButtons();
    // Re-setup image upload listeners on Turbo render
    // Use setTimeout to ensure DOM is fully loaded
    setTimeout(function() {
      if (typeof window.setupImageUploadListeners === 'function') {
        // Remove the setup flag to allow re-initialization
        const imageUploadZone = document.getElementById('image-upload-zone');
        const imageUploadInput = document.getElementById('image-upload-input');
        if (imageUploadZone && imageUploadInput) {
          imageUploadZone.removeAttribute('data-upload-listeners-setup');
          window.setupImageUploadListeners();
        } else {
          console.warn('Image upload elements not found on turbo:render');
        }
      }
    }, 50);
    // Reset client-side image selection state on each Turbo render (same reason as turbo:load)
    window.imageFiles = [];
    imageFiles = window.imageFiles;
    window.processingFiles = false;
    imageFileIdCounter = 0;

    // Remove any stale placeholders from cached DOM
    const grid = document.getElementById('image-thumbnails-grid');
    if (grid) {
      grid.querySelectorAll('.new-image-placeholder').forEach(function(el) { el.remove(); });
    }

    // Clear any stale removed image inputs from cached DOM
    const removedContainer = document.getElementById('removed-images-container');
    if (removedContainer) {
      removedContainer.innerHTML = '';
    }
    // Setup existing image drag handlers
    if (typeof window.setupExistingImageHandlers === 'function') {
      // Remove setup flag to allow re-initialization
      let existingImageGrid = document.getElementById('image-thumbnails-grid');
      if (existingImageGrid) {
        existingImageGrid.removeAttribute('data-drag-handlers-setup');
        existingImageGrid.removeAttribute('data-container-drag-setup');
      }
      setTimeout(function() {
        window.setupExistingImageHandlers();
        // After handlers are set up, initialize combined order with all existing images
        if (typeof window.updateCombinedImageOrder === 'function') {
          // Update immediately
          window.updateCombinedImageOrder();
          // And again after a delay to ensure it's set
          setTimeout(function() {
            window.updateCombinedImageOrder();
            console.log('Initialized combined order on turbo render');
          }, 150);
        }
      }, 100);
    }
    // Update upload zone visibility on render
    setTimeout(updateUploadZoneVisibility, 100);
  });
  
  
  // Also call initializeOnTurbo for other functionality
  document.addEventListener('turbo:load', initializeOnTurbo);
  document.addEventListener('turbo:render', initializeOnTurbo);
  
  // Global function for setting up existing image handlers (can be called from anywhere)
  window.setupExistingImageRemoveHandlers = function() {
    const existingImageGrid = document.getElementById('image-thumbnails-grid');
    if (!existingImageGrid || existingImageGrid.hasAttribute('data-remove-handlers-setup')) {
      return;
    }
    existingImageGrid.setAttribute('data-remove-handlers-setup', 'true');
    
    existingImageGrid.addEventListener('click', function(e) {
      const removeBtn = e.target.closest('.remove-existing-image');
      if (!removeBtn) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      const imageItem = removeBtn.closest('.existing-image-item');
      const imageId = removeBtn.getAttribute('data-image-id');
      
      if (!imageItem || !imageId) return;
      
      let container = document.getElementById('removed-images-container');
      if (!container) {
        container = document.createElement('div');
        container.id = 'removed-images-container';
        container.style.display = 'none';
        const formEl = document.querySelector('form');
        if (formEl) {
          formEl.appendChild(container);
        } else {
          const formField = document.querySelector('.form-field');
          if (formField && formField.parentElement) {
            formField.parentElement.appendChild(container);
          }
        }
      }
      
      if (!container.querySelector(`input[value="${imageId}"]`)) {
        const removedInput = document.createElement('input');
        removedInput.type = 'hidden';
        removedInput.name = 'removed_image_ids[]';
        removedInput.value = imageId;
        container.appendChild(removedInput);
        imageItem.style.display = 'none';
        imageItem.setAttribute('data-removed', 'true');
      }
    });
  };
  
  // Call immediately if DOM is ready
  if (document.readyState !== 'loading') {
    window.setupExistingImageRemoveHandlers();
  }
  
  // Also listen for page load events
  document.addEventListener('DOMContentLoaded', window.setupExistingImageRemoveHandlers);
  
  // Listen for Turbo events if using Turbo (Rails 7+)
  if (typeof Turbo !== 'undefined') {
    document.addEventListener('turbo:load', window.setupExistingImageRemoveHandlers);
    document.addEventListener('turbo:render', window.setupExistingImageRemoveHandlers);
  }
  
  // Final fallback - call after a delay
  setTimeout(window.setupExistingImageRemoveHandlers, 200);
  
  // Hard-lock initialization guard (CRITICAL)
  // Reset on Turbo navigation to allow re-initialization
  let dragInitialized = false;
  
  // Initialize image drag swap functionality
  let draggedItem = null;
  
  // Store handlers so we can remove them on re-init
  let dragHandlers = {
    dragstart: null,
    dragover: null,
    drop: null,
    dragend: null
  };
  
  function swapByIndex(container, a, b) {
    const items = Array.from(container.children);
    
    const aIndex = items.indexOf(a);
    const bIndex = items.indexOf(b);
    
    if (aIndex === -1 || bIndex === -1) return;
    
    // Swap in array
    [items[aIndex], items[bIndex]] = [items[bIndex], items[aIndex]];
    
    // Atomic DOM rebuild - clear and rebuild to prevent partial state
    container.innerHTML = '';
    items.forEach(function(item) {
      container.appendChild(item);
    });
    
    // Update order after swap
    if (typeof updateImageOrder === 'function') {
      updateImageOrder();
    }
    if (typeof window.updateCombinedImageOrder === 'function') {
      window.updateCombinedImageOrder();
    }
    if (typeof window.updateExistingImageOrder === 'function') {
      window.updateExistingImageOrder();
    }
    if (typeof window.updateExistingImageIndices === 'function') {
      window.updateExistingImageIndices();
    }
  }
  
  function initImageDragSwap() {
    const grid = document.getElementById('image-thumbnails-grid');
    if (!grid) {
      // Grid not ready yet, will retry
      return false;
    }
    
    // Check if already initialized on this grid instance
    if (grid.hasAttribute('data-drag-initialized')) {
      // Remove old handlers if they exist
      if (dragHandlers.dragstart) {
        grid.removeEventListener('dragstart', dragHandlers.dragstart);
      }
      if (dragHandlers.dragover) {
        grid.removeEventListener('dragover', dragHandlers.dragover);
      }
      if (dragHandlers.drop) {
        grid.removeEventListener('drop', dragHandlers.drop);
      }
      if (dragHandlers.dragend) {
        grid.removeEventListener('dragend', dragHandlers.dragend);
      }
    }
    
    // Mark as initialized
    grid.setAttribute('data-drag-initialized', 'true');
    
    // Add .image-item class to all items for consistent selection
    const allItems = grid.querySelectorAll('.existing-image-item, .image-thumbnail-item, .new-image-placeholder');
    allItems.forEach(function(item) {
      item.classList.add('image-item');
    });
    
    // Create handler functions
    dragHandlers.dragstart = function(e) {
      // Don't start drag if clicking on a button
      if (e.target.closest('button')) {
        e.preventDefault();
        return false;
      }
      
      const item = e.target.closest('.image-item');
      if (!item) return;
      
      draggedItem = item;
      e.dataTransfer.setData('text/plain', '');
    };
    
    dragHandlers.dragover = function(e) {
      e.preventDefault();
    };
    
    dragHandlers.drop = function(e) {
      e.preventDefault();
      
      // Sanity guard: ensure draggedItem is still in the grid
      if (!grid.contains(draggedItem)) {
        draggedItem = null;
        return;
      }
      
      // Handle drop of new image from top section first
      if (window.draggedElement && window.draggedElement.classList && window.draggedElement.classList.contains('image-preview-item')) {
        try {
          const dragData = e.dataTransfer.getData('application/json');
          if (dragData) {
            const data = JSON.parse(dragData);
            if (data.type === 'new-image') {
              const fileId = data.fileId;
              const file = window.imageFiles ? window.imageFiles.find(function(f) {
                return (f._uniqueId || '') === fileId;
              }) : null;
              
              if (file) {
                const targetItem = e.target.closest('.image-item');
                
                // Create placeholder
                const placeholder = document.createElement('div');
                placeholder.className = 'image-thumbnail-item new-image-placeholder image-item';
                placeholder.setAttribute('draggable', 'true');
                placeholder.dataset.fileId = fileId;
                placeholder.dataset.isNew = 'true';
                placeholder.dataset.isExisting = 'false';
                
                const reader = new FileReader();
                reader.onload = function(e) {
                  placeholder.innerHTML = `
                    <img src="${e.target.result}" class="thumbnail-image" draggable="false">
                    <button type="button" class="remove-thumbnail-image" data-file-id="${fileId}" title="Remove image">×</button>
                    <span class="new-image-badge">NEW</span>
                  `;
                  
                  // Insert before the target item if found, otherwise append
                  if (targetItem) {
                    grid.insertBefore(placeholder, targetItem);
                  } else {
                    grid.appendChild(placeholder);
                  }
                  
                  // Remove from new images
                  if (window.draggedElement && window.draggedElement.remove) {
                    window.draggedElement.remove();
                  }
                  
                  // Update arrays
                  if (window.imageFiles) {
                    const fileIndex = window.imageFiles.findIndex(function(f) {
                      return (f._uniqueId || '') === fileId;
                    });
                    if (fileIndex !== -1) {
                      window.imageFiles.splice(fileIndex, 1);
                      if (typeof updateFileInput === 'function') {
                        updateFileInput();
                      }
                      if (typeof updateImageOrder === 'function') {
                        updateImageOrder();
                      }
                    }
                  }
                  
                  // Update combined order
                  if (typeof window.updateCombinedImageOrder === 'function') {
                    window.updateCombinedImageOrder();
                  }
                  
                  // Setup handlers
                  if (typeof window.setupPlaceholderDragHandlers === 'function') {
                    window.setupPlaceholderDragHandlers(placeholder, file);
                  }
                  
                  // Update preview visibility
                  const imagePreviewContainer = document.getElementById('image-preview-container');
                  if (window.imageFiles && window.imageFiles.length === 0 && imagePreviewContainer) {
                    imagePreviewContainer.style.display = 'none';
                  }
                };
                reader.readAsDataURL(file);
                
                if (window.draggedElement) {
                  window.draggedElement = null;
                }
                
                // Update order
                if (typeof window.updateCombinedImageOrder === 'function') {
                  window.updateCombinedImageOrder();
                }
                if (typeof window.updateExistingImageIndices === 'function') {
                  window.updateExistingImageIndices();
                }
                
                return;
              }
            }
          }
        } catch (err) {
          console.error('Error handling drop:', err);
        }
      }
      
      // Handle swap of existing images
      const target = e.target.closest('.image-item');
      if (!draggedItem || !target || draggedItem === target) return;
      
      // Sanity guard: ensure both items are still in the grid
      if (!grid.contains(draggedItem) || !grid.contains(target)) {
        draggedItem = null;
        return;
      }
      
      swapByIndex(grid, draggedItem, target);
    };
    
    dragHandlers.dragend = function() {
      draggedItem = null;
    };
    
    // Add event listeners
    grid.addEventListener('dragstart', dragHandlers.dragstart);
    grid.addEventListener('dragover', dragHandlers.dragover);
    grid.addEventListener('drop', dragHandlers.drop);
    grid.addEventListener('dragend', dragHandlers.dragend);
    
    return true; // Successfully initialized
  }
  
  // Reset initialization flag on Turbo navigation
  document.addEventListener('turbo:before-cache', function() {
    dragInitialized = false;
    draggedItem = null;
  });
  
  // Initialize on page load with retry logic
  function tryInitImageDragSwap(retries = 3) {
    if (initImageDragSwap()) {
      return true;
    }
    if (retries > 0) {
      setTimeout(function() {
        tryInitImageDragSwap(retries - 1);
      }, 100);
    }
    return false;
  }
  
  document.addEventListener('turbo:load', function() {
    dragInitialized = false; // Reset on Turbo load
    setTimeout(function() {
      tryInitImageDragSwap(5);
    }, 50);
  });
  
  document.addEventListener('turbo:render', function() {
    dragInitialized = false; // Reset on Turbo render
    setTimeout(function() {
      tryInitImageDragSwap(5);
    }, 50);
  });
  
  document.addEventListener('DOMContentLoaded', function() {
    tryInitImageDragSwap(5);
  });
  
  // Also call immediately if DOM is ready
  if (document.readyState !== 'loading') {
    setTimeout(function() {
      tryInitImageDragSwap(5);
    }, 50);
  }
</script>
